#!/bin/sh
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License 3 as published
# by the Free Software Foundation.
# THERE IS NO ANY WARRANTY AT ALL

# MODIFIED: run() -> __run()
___srV="2.6.0_m";[ -z "$___srD" ] && ___srD=0;___sw(){ case "$1" in "$2"*) return 0;;esac;return 1;};___ew(){ case "$1" in *"$2") return 0;;esac;return 1;};___rp(){ eval 'readlink -f "'$1'" 2>/dev/null';};___sw "$(echo -e t)" "-e" || alias echo="echo -e";_chkargs(){ local fn=;local nr=;fn="$1";nr="$2";shift 2;[ ! $# -eq $nr ] && { echo "(sr) $__file__: $fn(): needs $nr arg(s), $# given";exit 1;};};_chkargsm(){ local fn=;local nr=;fn="$1";nr="$2";shift 2;[ ! $nr -le $# ] && { echo "(sr) $__file__: $fn(): needs at least $nr arg(s), $# given";exit 1;};};__DIFS=$IFS;__rdIFS(){ IFS=$__DIFS; };__cIFS(){ local __fn='__cIFS';_chkargs ${__fn} 2 "$@";local __oifs=; __oifs="${1}__oifs";eval "export ${__oifs}='$IFS'";IFS=$2;};__rIFS(){ local __fn='__rIFS'; _chkargs ${__fn} 1 "$@";local __oifs=; __oifs="${1}__oifs";eval 'IFS="${'"${__oifs}"'}"';};IN(){ local __i=;local __r=1;[ -n "$3" ] && __cIFS '_IN_' "$3";for __i in $2;do [ "$1" = "$__i" ] && { __r=0;break;};done;[ -n "$3" ] && __rIFS '_IN_';return $__r;};__run(){ [ -n "$__rE" ] || [ "$DBG_RUN" = "1" ] && echo "run: $@";eval "$@";return $?;};run_e(){ __rE=1 run "$@";__rEr=$?;__rE=;return $__rEr;};__is_bbash__=0;__is_bash__=0;[ -n "$BASH" ] && { __is_bbash__=1; shopt -s expand_aliases;};___ew "$BASH" "bash" && { __is_bash__=1;};__is_dbg__=0; [ $__is_bash__ = 1 ] && [ -n "$_Dbg_DEBUGGER_LEVEL" ] && __is_dbg__=1;__name__=;_az=;if [ -n "$__sr_inc_rp" ];then _az=$__sr_inc_rp; unset __sr_inc_rp;else if [ -z "$__main__" ];then __name__=__main__;export __modules__=;fi;[ $__is_bbash__ = 1 ] && _az=$(___rp '${''BASH_SOURCE[0]''}');[ -z "$_az" ] && _az=${0};fi;__pid__=$$;__cwd__=$(pwd);__f_path__=$(___rp "${_az}");[ -n "$__HDBDB_RP_" ] && { __f_path__=$__HDBDB_RP_; export __HDBDB_RP_=;};__path__=${__f_path__%/*};__file__=${__f_path__##*/};__ns__=${__file__%.*};[ "$__name__" != "__main__" ] && { __name__=$__main__; __main__=$__main__;} || { __main__=$__file__;};_az=;add_sr_PATH(){ ! IN "$1" "${sr_PATH}" ":" && export sr_PATH="${1}:${sr_PATH}";};add_sr_PATH "$__path__";[ -n "$CMDER_ROOT" ] && WIN_CMD_ROOT=$(___rp "${CMDER_ROOT}");

# this is hdfind: find stuff with increased usability
# 2008-2021: Dieter Hilfer
# the zen of hdfind:
#   - be one file-tool
#   - run on sh, bash, busybox-sh, windows mingw/git-like environments
#   - do not use persistence (except for intermediate helper):
#       - HDFIND_ENABLE_KEEP_LAST_RESULT
#       - HDFIND_ENABLE_TOOL_FEATURE_CACHE
#     which can easily be disabled
#   - exec speed is not as important, as usability (and code maintainability)

__VERSION__="7.8.2"

BASIC_USAGE="(${__VERSION__}): hdfind [-C search_dir] [OPTIONS(--help to show)] [--] PATTERN [PATTERN PATTERN ...]"

# control persistence here
HDFIND_ENABLE_KEEP_LAST_RESULT=1
# this will save you A LOT of time while startup on Windows
HDFIND_ENABLE_TOOL_FEATURE_CACHE=1

# ignore search here by default
FIND_IGNORE_PATTTERNS='
/.svn/*
/.git/*
/.cmake/*
/__pycache__/*
'

# upgrade stuff
UPGRADE_LATEST_RELEASE_LINK="https://raw.githubusercontent.com/dhilfer/hdtools/hdfind-latest/hdfind"
UPGRADE_UNIQUE_TOKEN="bba20c00-f039-45ec-affa-6be03c698135"

if true; then                                                           # grep color scheme
COLOR_SCHEME_GREP_HD='ms=43;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=' #1.0.1
COLOR_SCHEME=${COLOR_SCHEME_GREP_HD}
export GREP_COLORS=${COLOR_SCHEME}
fi
if true; then                                                           # run echo's, baselib
run() { [ "${CMD_LINE_OPT__DRY}" != "1" ] && __run "$*"; return $?; }
echo_stderr()    { >&2 echo "$@"; }
echo_red() { echo "\033[31m${@}\033[0m"; }
echo_yellow() { echo "\033[33m${@}\033[0m"; }
lognotice()  { [ "${CMD_LINE_OPT__VERBOSE}" = "1" ] && echo_stderr " [notice]: $@"; }
logwarning() { [ "${CMD_LINE_OPT__VERBOSE}" = "1" ] && echo_stderr "$(echo_yellow "[warning]: $@")"; }
logerror()   { echo_stderr "$(echo_red    "  [error]: $@")"; } # always show errors
# check os tools
_cet() { local _T=;local _A=;_T=$(echo "${1}" | cut -d":" -f1);_A=$(echo "${1}" | cut -d":" -f2);[ -n "$(which ${_T})"  ] || { logwarning "${_T}: was not found. try: sudo apt-get install ${_A} , or so"; return 1 ; } ; }
_ct() { local ret=; local _i=; ret=0; for _i in ${1} ; do _cet "${_i}"; if [ "$?" != "0" ]; then ret=1; fi; done; if [ "$ret" != "0" ]; then  exit 1; fi; }
# sed must support binary patterns (some busybox sed does not)
SED_SUPPORTS_BINARY_PATTERNS=0; [ -z "$(echo "1" | sed -r 's!([0-9]+)!\x1b[32m\1\x1b[0m!g' | grep x1b)" ] && SED_SUPPORTS_BINARY_PATTERNS=1
if [ "${SED_SUPPORTS_BINARY_PATTERNS}" = "1" ] ; then
    strip_colors() { echo "$@" | sed -r 's/\x1B\[([0-9]{1,2}(;[0-9]{1,3}(;[0-9]{1,3}(;[0-9]{1,3}(;[0-9]{1,3}(;[0-9]{1,3})?)?)?)?)?)?[mGK]//g' ; }
else
    strip_colors() { echo "$@"; }
fi

fi
if true; then                                                           # persistence setup
_handle_pers_setup()
{
    if [ -n "${WIN_CMD_ROOT}" ]; then
        # we are on Windows
        HDGREP_LAST_RESULT_TMP_FILE="${WIN_CMD_ROOT}/tmp/hdgrep.last_result"
        HDFIND_CTSO_CACHE_TMP_FILE="${WIN_CMD_ROOT}/tmp/hdfind.ctso"
    else
        local _xpref="/tmp/"
        if [ -n "${XDG_RUNTIME_DIR}" ] ; then
            # try work with XDG tmpfs
            _xpref="${XDG_RUNTIME_DIR}"
        fi
        HDGREP_LAST_RESULT_TMP_FILE="${_xpref}/hdgrep.$(whoami).last_result"
        HDFIND_CTSO_CACHE_TMP_FILE="${_xpref}/hdfind.ctso"
    fi


    [ "${HDFIND_ENABLE_KEEP_LAST_RESULT}" != "1" ] && HDGREP_LAST_RESULT_TMP_FILE=
    [ "${HDFIND_ENABLE_TOOL_FEATURE_CACHE}" != "1" ] && { HDFIND_CTSO_CACHE_TMP_FILE= ; }
}
_handle_pers_setup
fi
if true; then                                                           # options
# MODIFIED: # extends FIND_IGNORE_PATTTERNS, pretty usage, extended comment at [ "${broken_opts}" = "1" ]
print_usage()
{
    # options
    echo "${BASIC_USAGE}

Search for FILES, DIRS, LINKS, etc. matching '*PATTERN*' in name.
If given, standard input (stdin) is interpreted as a LIST OF PATHS to
search in.

hdfind is a friendly wrapper for find (utilizing more tools such as:
grep, xargs, [ls, nl, tee, cut, md5sum, wget])

If running first time hdfind will scan supported features of used tools.
Something like: can grep produce colored output? The result will be
cached, and reloaded on later runs.
The cache file is normally stored under a volatile tmp/, so after reboot
a rescan is done again. This ensures cache/tool-feature updates  once in
a while. You can force immediate rescan by using: --rescan-tools-opts

If hdfind does not behave like you expect, maybe you should rerun with
--verbose/-v flag to see useful messages and the real find command.

[OPTIONS]:
  -h      --help              this help
          --rescan-tools-opts reset tools options cache and rescan
                              supported tools features (use with
                              --verbose/-v flag to see more details)


------------ SEARCH RELATED OPTIONS --------------

  -C      --chdir DIR         change directory before starting search

  -i      --ignore-case       ignore word case
  -E      --exact             search for 'PATTERN', not for '*PATTERN*'
  -md5    --md5               PATTERN is an MD5 hash


  -tf     --type-file         search for files
  -td     --type-dir          search for directories
  -tl     --type-link         search for symbolic links
  -tc     --type-chardev      search for char devices


  -e      --exclude-path PATH You can specify multiple path patterns
                              which should be excluded from search.
                              (e.g: -e '/.build' -e '/.cmake')
                              hdfind presets some paths like /.svn,
                              ./git etc. Show them using --verbose/-v
                              option. To disable exclude paths use
                              -J/--ignore-exclude option.
  -J      --ignore-exclude    Ignore all specified and predefined
                              -e/--exclude-paths

  -d      --depth DEPTH       stop search at DEPTH
  -s      --size [+|-]N[ckMG] consider file SIZE N (integer only):
                              Following suffixes can be used:
                                'c':B, 'k':kB, 'M':MB  [default], 'G':GB

                              The + and - [default] prefixes signify
                              greater than and less than.
                              (e.g: -s 5: find files with less than 5MB,
                                    -s +3G: find files greater than 3GB)


------------ DISPLAY RESULTS OPTIONS -------------

Choosing one of the following --show-X-only options  might be helpful to
pipe hdfind  results to  other  tools (e.g.: grep).  It will also advice
hdfind NOT to store last search results in a tmp file (currently):
  ${HDGREP_LAST_RESULT_TMP_FILE}

  -sm     --show-match-only   show matching RESULTS only
  -sd     --show-dirs-only    show DIRS  containing match  PATTERNS only
  -D      --show-defaults     force  default  show behaviour  (overrides
                              any --show-X-only)
hdfind will try  to force  colored output  on every search. However from
time to time it's more convinient to disable colors (e.g. on output
redirection)
  -dc     --disable-color     disable colored output


------------ OTHER OPTIONS -----------------------

  -dry    --dry               show  calls only, don't perform any search
  -v      --verbose           print messages (which may help you to
                              analyze hdfind's behaviour)
          --upgrade           try  to upgrade  hdfind to latest version,
                              using this link:
                                ${UPGRADE_LATEST_RELEASE_LINK}
"
}

CMD_LINE_OPT__RESCAN_TOOLS_OPTS="0"  # -
CMD_LINE_OPT__IGNORE_CASE="0"  # -
CMD_LINE_OPT__EXACT="0"  # -
CMD_LINE_OPT__MD5="0"  # -
CMD_LINE_OPT__TYPE_FILE="0"  # -
CMD_LINE_OPT__TYPE_DIR="0"  # -
CMD_LINE_OPT__TYPE_LINK="0"  # -
CMD_LINE_OPT__TYPE_CHARDEV="0"  # -
CMD_LINE_OPT__DEPTH=""  # -
CMD_LINE_OPT__SIZE=""  # -
CMD_LINE_OPT__CHDIR="./"  # -
CMD_LINE_OPT__EXCLUDE_PATH=""  # -
CMD_LINE_OPT__FOLLOW_SYMLINKS="0"  # -
CMD_LINE_OPT__SHOW_MATCH_ONLY="0"  # -
CMD_LINE_OPT__SHOW_DIRS_ONLY="0"  # -
CMD_LINE_OPT__SHOW_DEFAULTS="0"  # -
CMD_LINE_OPT__DISABLE_COLOR="0"  # -
CMD_LINE_OPT__VERBOSE="0"  # -
CMD_LINE_OPT__DRY="0"  # -
CMD_LINE_OPT__IGNORE_EXCLUDE="0"  # -
CMD_LINE_OPT__UPGRADE="0"  # -
CMD_LINE_OPT__RESCAN_TOOLS_AND_SUPPORTED_OPTIONS="0"  # -
parse_all_options()
{
    local shifted=
    shifted=0
    local broken_opts=
    while [ "$#" -gt 0 ]; do
        case "${1}" in
            --)
            # end of option list
                shift 1; shifted=$((shifted+1))
                break;;
            --help|-h)
                print_usage; exit 0;;
            # -
            --rescan-tools-opts)
                CMD_LINE_OPT__RESCAN_TOOLS_OPTS="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --ignore-case|-i)
                CMD_LINE_OPT__IGNORE_CASE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --exact|-E)
                CMD_LINE_OPT__EXACT="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --md5|-md5)
                CMD_LINE_OPT__MD5="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --type-file|-tf)
                CMD_LINE_OPT__TYPE_FILE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --type-dir|-td)
                CMD_LINE_OPT__TYPE_DIR="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --type-link|-tl)
                CMD_LINE_OPT__TYPE_LINK="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --type-chardev|-tc)
                CMD_LINE_OPT__TYPE_CHARDEV="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --depth|-d)
                CMD_LINE_OPT__DEPTH="$2"
                [ $# -lt 2 ] || [ "$2" = "--" ] && { echo "--depth|-d needs an additional parameter" >&2; exit 1; };
                shift 2; shifted=$((shifted+2));;
            # -
            --size|-s)
                CMD_LINE_OPT__SIZE="$2"
                [ $# -lt 2 ] || [ "$2" = "--" ] && { echo "--size|-s needs an additional parameter" >&2; exit 1; };
                shift 2; shifted=$((shifted+2));;
            # -
            --chdir|-C)
                CMD_LINE_OPT__CHDIR="$2"
                [ $# -lt 2 ] || [ "$2" = "--" ] && { echo "--chdir|-C needs an additional parameter" >&2; exit 1; };
                shift 2; shifted=$((shifted+2));;
            # -
            --exclude-path|-e)
                CMD_LINE_OPT__EXCLUDE_PATH="$2"
                [ $# -lt 2 ] || [ "$2" = "--" ] && { echo "--exclude-path|-e needs an additional parameter" >&2; exit 1; };

                # extend FIND_IGNORE_PATTTERNS
                FIND_IGNORE_PATTTERNS="${FIND_IGNORE_PATTTERNS}
${CMD_LINE_OPT__EXCLUDE_PATH}"

                shift 2; shifted=$((shifted+2));;
            # -
            --follow-symlinks|-L)
                CMD_LINE_OPT__FOLLOW_SYMLINKS="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --show-match-only|-sm)
                CMD_LINE_OPT__SHOW_MATCH_ONLY="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --show-dirs-only|-sd)
                CMD_LINE_OPT__SHOW_DIRS_ONLY="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --show-defaults|-D)
                CMD_LINE_OPT__SHOW_DEFAULTS="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --disable-color|-dc)
                CMD_LINE_OPT__DISABLE_COLOR="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --verbose|-v)
                CMD_LINE_OPT__VERBOSE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --dry|-dry)
                CMD_LINE_OPT__DRY="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --ignore-exclude|-J)
                CMD_LINE_OPT__IGNORE_EXCLUDE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --upgrade)
                CMD_LINE_OPT__UPGRADE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --rescan-tools-and-supported-options)
                CMD_LINE_OPT__RESCAN_TOOLS_AND_SUPPORTED_OPTIONS="1"
                shift 1 ; shifted=$((shifted+1));;
            -*)
              echo "unknown option: $1" >&2
              broken_opts=1
              shift 1;;
            *)
              # options parse done
              break ;;
      esac
    done

    [ "${broken_opts}" = "1" ] && { echo "run with --help to see available options" >&2; exit 1; };

    return ${shifted}
}
# parse early
parse_all_options "$@"
shift $?
if [ "${CMD_LINE_OPT__DISABLE_COLOR}" = "1" ]; then
    echo_yellow() { echo "$@"; }
    echo_red()    { echo "$@"; }
fi
fi
if true; then                                                           # get running conditions
# echo "/path/to/file" | hdfind file
DO_I_RUN_INTERACTIVELY=
_get_running_conditions_simple()
{
    if [ ! -t 0 ] ; then DO_I_RUN_INTERACTIVELY="1" ; fi
}
_get_running_conditions_simple
#echo "DO_I_RUN_INTERACTIVELY: $DO_I_RUN_INTERACTIVELY"
fi
if true; then                                                           # _csto: v2.0.0
_ctso_prev_tool=
_ctso_prev_cache=
_ctso_pers_cache_path="$HDFIND_CTSO_CACHE_TMP_FILE"
_ctso_pers_cache_loaded=0
_ctso() #(tool, option_regex, *feature, [ignore_cache="0", check_opt="--help"])
{
    local __fn='_ctso'; _chkargsm ${__fn} 3 "$@"

    local tool=
    local option_regex=
    local export_var_feature=
    local ignore_cache=
    local check_opt=
    tool="${1}"
    option_regex="${2}"
    export_var_feature="${3}" ; eval "export ${export_var_feature}"
    ignore_cache="${4}"
    check_opt="${5}"

    [ -z "${ignore_cache}" ] && ignore_cache=0
    [ -z "${check_opt}" ] && check_opt="--help"

    # ----------
    local ret_feature=

    # ----------------------------------------

    if [ "${ignore_cache}" = "0" ] && [ "${_ctso_pers_cache_loaded}" = "0" ] && [ -n "${_ctso_pers_cache_path}" ] ; then
        # try load persistence cache once
        [ -e "${_ctso_pers_cache_path}" ] && . "${_ctso_pers_cache_path}"
        _ctso_pers_cache_loaded=1
    fi
    if [ "${ignore_cache}" = "0" ] && [ -n "$(eval echo "$""$export_var_feature")"  ]; then
        return 0;
    fi

    ret_feature=0
    local ret=

    if [ "${_ctso_prev_tool}" != "${tool}" ]; then
        # update cache
        _ctso_prev_cache=$(${tool} ${check_opt} 2>&1)
        _ctso_prev_tool=${tool}
    fi
    #local tool_real=
    #tool_real=$(echo "${_ctso_prev_cache}" | sed -nr 's!(.*)('${option_regex}')(.*)!\2!p' | head -n 1)
    #if [ "${tool_real}" = "${option_regex}" ]; then
    echo "${_ctso_prev_cache}" | grep -w -e "${option_regex}" >/dev/null 2>&1
    ret="$?"
    if [ "$ret" = "0" ]; then
        # ok
        ret_feature=1
    fi

    if [ "${ignore_cache}" = "0" ] && [ -n "${_ctso_pers_cache_path}" ] ; then
        echo "export ${export_var_feature}=${ret_feature}" >> "${_ctso_pers_cache_path}"
    fi

    lognotice "scan tool feature: ${tool}: ${option_regex}: $( [ ${ret_feature} = 1 ] && echo "OK" || echo "NOK" )"
    # ----------------------------------------
    # return values
    eval "export ${export_var_feature}='${ret_feature}'"
    return $ret
}
_ctso_reset_pers_cache() #()
{
    if [ -f "${HDFIND_CTSO_CACHE_TMP_FILE}" ] ; then
        logwarning "reset csto persistence cache: ${HDFIND_CTSO_CACHE_TMP_FILE}"
        cmd="rm '${HDFIND_CTSO_CACHE_TMP_FILE}'"
        run "${cmd}"
        _ctso_pers_cache_loaded=0
    fi
}
if [ "${CMD_LINE_OPT__RESCAN_TOOLS_OPTS}" = "1" ] ; then
    logwarning "--rescan-tools-opts: reset tools options cache"
    _ctso_reset_pers_cache
fi
fi
if true; then                                                           # check tools, and features
# basic tooling

#grep features
_ctso "grep" "--color" GREP_CAN_COLOR
_ctso "grep" "-i" GREP_CAN_IGNORECASE
_ctso "grep" "-F" GREP_CAN_FIXEDSTRING
_ctso "grep" "-e" GREP_CAN_EXPLICIT_PATTERN

# find features
_ctso "find" "-print0" FIND_CAN_PRINT0
_ctso "find" "-wholename" FIND_CAN_WHOLENAME
_ctso "find" "-not" FIND_CAN_NOT
_ctso "find" "-maxdepth" FIND_CAN_MAXDEPTH
_ctso "find" "-size" FIND_CAN_SIZE
_ctso "find" "-iname" FIND_CAN_INAME
_ctso "find" "-or" FIND_CAN_OR

# xargs features
_ctso "xargs" "-0" XARGS_CAN_0
_ctso "xargs" "-P" XARGS_CAN_MULTIPROCESS
_ctso "xargs" "-I" XARGS_CAN_STRING_REPLACE

# optional tooling
# nl
_cet "nl" && NL_EXISTING="1";
# no nl, no sense for last search
[ "${NL_EXISTING}" != "1" ] && { logwarning "no nl: disable results persistence" ; HDGREP_LAST_RESULT_TMP_FILE=;}
if [ "${NL_EXISTING}" = "1" ]; then
    _ctso "nl" "-w" NL_CAN_NUMBER_WIDTH
    _ctso "nl" "-s" NL_CAN_NUMBER_SEPARATOR
fi
fi
if true; then                                                           # upgrade
run_upgrade() #(name_info, upgrade_link, check_token, version_regex, target_path, target_file)
{
    local __fn='run_upgrade'; _chkargs ${__fn} 6 "$@"

    local name_info=
    local upgrade_link=
    local check_token=
    local version_regex=
    local target_path=
    local target_file=
    name_info="${1}"
    upgrade_link="${2}"
    check_token="${3}"
    version_regex="${4}"
    target_path="${5}"
    target_file="${6}"

    local ret=
    local cmd=
    local err_msg=
    err_msg="
something went wrong:
    - check write access to: ${target_path},
    - check the upgrade link: ${upgrade_link}
"

    local target_tmp_file=
    target_tmp_file="${target_path}/${target_file}._upgrade.tmp"

    lognotice "run upgrade for ${name_info} ..."

    # don't consider 1000 possible wget variants/settings, just get it
    lognotice "download data (to ${target_tmp_file}) ...
"
    cmd="wget '${upgrade_link}' -O - > '${target_tmp_file}'"
    run "${cmd}"
    ret=$?
    if [ "${ret}" != "0" ]; then
        # broken multiline colored on stderr on windows
        #logerror "${err_msg}"
        >&2 echo_red "[error]: ${err_msg}"
        exit 1
    fi

    # now check unique token
    lognotice "check contents ..."
    local tok_ok=
    tok_ok=$(cat "${target_tmp_file}" | grep "${check_token}")
    if [ -z "${tok_ok}" ]; then
        cmd="rm -f '${target_tmp_file}'"
        run "${cmd}"
        # broken multiline colored on stderr on windows
        >&2 echo_red "[error]: ${err_msg}"
        exit 1
    fi

    # is valid
    local new_version_str=
    new_version_str=$(cat "${target_tmp_file}" | sed -nr "${version_regex}")

    lognotice "replace old version ..."
    cmd="mv '${target_tmp_file}' '${target_path}/${target_file}'"
    run "${cmd}"
    ret=$?
    if [ "${ret}" != "0" ]; then
        # broken multiline colored on stderr on windows
        >&2 echo_red "[error]: ${err_msg}"
        exit 1
    fi

    if [ -z "${WIN_CMD_ROOT}" ] ; then
        # chmod in linux only
        cmd="chmod +x '${target_path}/${target_file}'"
        run "${cmd}"
    fi

    lognotice "ALL GOOD. ${name_info} was upgraded: ${__VERSION__} -> ${new_version_str}"
    exit 0
}
fi
if true; then                                                           # work helper
get_ONE_pattern_set() #(pattern_in, *find_p, *grep_p)
{
    local __fn='get_ONE_pattern_set'; _chkargs ${__fn} 3 "$@"

    local pattern_in=
    local export_var_find_p=
    local export_var_grep_p=
    pattern_in="${1}"
    export_var_find_p="${2}" ; eval "export ${export_var_find_p}"
    export_var_grep_p="${3}" ; eval "export ${export_var_grep_p}"

    # ----------
    local ret_find_p=
    local ret_grep_p=


    # ----------------------------------------
    local find_p=
    local grep_p=
    local tmp=

    find_p="${pattern_in}"
    grep_p="${pattern_in}"


    if ___sw "${grep_p}" "*"; then
        grep_p=$(echo "${grep_p}" | cut -c2-)
    fi
    tmp=${#grep_p}
    tmp=$((tmp-1))
    if ___ew "${grep_p}" "*"; then
        grep_p=$(echo "${grep_p}" | cut -c1-${tmp})
    fi
    grep_p=$(echo "${grep_p}" | sed -r 's!\*!\.\*!g')

    if [ "${CMD_LINE_OPT__EXACT}" != "1" ] ; then
        if ___sw "${find_p}" "*" || ___ew "${find_p}" "*"; then
            true # pass
        else
            find_p="*${find_p}*"
        fi
    fi

    ret_find_p="${find_p}"
    ret_grep_p="${grep_p}"

    # ----------------------------------------
    # return values
    eval "export ${export_var_find_p}='${ret_find_p}'"
    eval "export ${export_var_grep_p}='${ret_grep_p}'"
    return 0
}
get_real_find_file_and_grep_patterns() #(use_p0, find_options_size, find_options_type, *real_find_file_pattern, *real_grep_for_this, *real_find_file_pattern_info)
{
    local __fn="get_real_find_file_and_grep_patterns"; _chkargsm "${__fn}" 6 "$@"

    local use_p0=; use_p0="${1}";
    local find_options_size=; find_options_size="${2}";
    local find_options_type=; find_options_type="${3}";
    local export_var_real_find_file_pattern=; export_var_real_find_file_pattern="${4}";
    eval "export ${export_var_real_find_file_pattern}=";
    local export_var_real_grep_for_this=; export_var_real_grep_for_this="${5}";
    eval "export ${export_var_real_grep_for_this}=";
    local export_var_real_find_file_pattern_info=; export_var_real_find_file_pattern_info="${6}";
    eval "export ${export_var_real_find_file_pattern_info}=";
    local ret_real_find_file_pattern=
    local ret_real_grep_for_this=
    local ret_real_find_file_pattern_info=

    # ---

    shift 6
    local find_file_pattern=
    local find_file_pattern_info=
    local grep_for_this=
    local tmp=
    local i=

    local ignore_search_case_for_grep=
    local ignore_search_case_for_find="-name"
    if [ "${CMD_LINE_OPT__IGNORE_CASE}" = "1" ] ; then
        ignore_search_case_for_grep="-i"
        ignore_search_case_for_find="-iname"
    fi

    if [ $# -eq 0 ]; then
        echo "${BASIC_USAGE}"
        exit 1
    elif [ $# -gt 1 ]; then
        if [ "${FIND_CAN_OR}" != "1" ] ; then
            CMD_LINE_OPT__VERBOSE=1
            logerror "'find' does not support -or, search for more than one PATTERN is not possible"
            exit 1
        fi
    fi

    local pattern_in=
    local pattern_in_fix=
    local _fr=0
    local _p0=
    [ "${FIND_CAN_PRINT0}" = "1" ] && [ "${XARGS_CAN_0}" = "1" ] && _p0="-print0";
    while [ $# -gt 0 ]; do
        if [ $_fr -ne 0 ]; then
            grep_for_this="${grep_for_this}\\|"
            find_file_pattern="${find_file_pattern} -or"
        fi

        _fr=1
        pattern_in=${1}
        # make sure user didn't specify a path: e.g.: ./js/hd/ui/hd_ui.js
        # take LAST part only, throw warning in verbose mode
        pattern_in_fix=${pattern_in##*/}
        if [ "${pattern_in}" != "${pattern_in_fix}" ] ; then
            logwarning "you specified a PATH to search for: '${pattern_in}', this is NOT how it should work"
            logwarning "I assume you look for: '${pattern_in_fix}', I'll search for that"
        fi
        get_ONE_pattern_set "${pattern_in_fix}" FIND_P GREP_P

        find_file_pattern_info="${find_file_pattern_info}\"${FIND_P}\", " # keep comma here!
        find_file_pattern="${find_file_pattern} ${ignore_search_case_for_find} \"${FIND_P}\" ${find_options_size} ${find_options_type}"
        if [ "${use_p0}" = "1" ] ; then
            find_file_pattern="${find_file_pattern} ${_p0}"
        fi

        grep_for_this="${grep_for_this}${GREP_P}"

        shift 1
    done
    if [ "${CMD_LINE_OPT__MD5}" != "1" ] ; then
        ret_real_find_file_pattern="${find_file_pattern}"
    else
        # on md5 search, deliver all, but search for files only
        ret_real_find_file_pattern="-type f ${_p0}"
    fi
    ret_real_grep_for_this="\"${grep_for_this}\""
    ret_real_find_file_pattern_info="$find_file_pattern_info"

    # ---

    # return values
    eval "export ${export_var_real_find_file_pattern}='${ret_real_find_file_pattern}'"
    eval "export ${export_var_real_grep_for_this}='${ret_real_grep_for_this}'"
    eval "export ${export_var_real_find_file_pattern_info}='${ret_real_find_file_pattern_info}'"
    return 0
}

string_isnumber() { [ -z "${1}" ] && return 1 ; case ${1} in ''*[!0-9]*) return 1 ;; esac; return 0; }
string_len() #(str)
{
    local l=$(echo "${1}" | wc -c )
    l=$((l-1))
    echo ${l}
}
# full support for negative indexes for start and end, end is optional
string_slice() #(str, pos, endpos=)
{
    local str=
    local pos=
    local endpos=
    str="${1}"
    pos=${2}
    endpos=${3}
    local len=
    len=$(string_len "${str}")
    [ -z ${endpos} ] && endpos=${len}
    if [ ${pos} -lt 0 ] ; then pos=$((len+pos)); fi
    if [ ${pos} -lt 0 ] ; then pos=0; fi
    if [ ${endpos} -lt 0 ] ; then endpos=$((len+endpos));
    elif [ ${endpos} -eq 0 ] || [ ${endpos} -gt ${len} ] ; then endpos=${len} ; fi

    if [ ${len} -eq 0 ] || [ ${endpos} -lt 0 ] || [ ${pos} -ge ${endpos} ] || [ ${pos} -gt $((${len}-1)) ] ; then
        echo ""
        return
    fi
    pos=$((pos+1))
    local cmd=
    cmd='echo "'${str}'" | cut -c'${pos}'-'${endpos}
    eval "${cmd}"
}
prep_find_size() #(user_size, *real_size)
{
    local __fn='prep_find_size'; _chkargs ${__fn} 2 "$@"

    local user_size=
    local export_var_real_size=
    user_size="${1}"
    export_var_real_size="${2}" ; eval "export ${export_var_real_size}="

    # ----------
    local ret_real_size=
    # ----------------------------------------

    local pref=
    local suff=
    local val=
    if string_isnumber "${user_size}"; then
        pref="-"
        suff="M"
        val="${user_size}"
    else
        # try not to use "fancy" patterns e.g. ${#i}, ${i: -1},  ash, dash will fail
          if ___sw "${user_size}" '+'; then pref='+'; val=$(string_slice "${user_size}" 1);
        elif ___sw "${user_size}" '-'; then pref='-'; val=$(string_slice "${user_size}" 1);
        elif string_isnumber "$(echo "${user_size}" | cut  -c1 )"; then pref='-'; val="${user_size}" # default '-': less than
        else
            logerror "wrong value for --size/-s (prefix): ${user_size}"
            exit 1
        fi

        if string_isnumber "${val}"; then
            suff="M"
        else
            # messy but safe
              if ___ew "${user_size}" 'c'; then suff='c'
            elif ___ew "${user_size}" 'k'; then suff='k'
            elif ___ew "${user_size}" 'M'; then suff='M'
            elif ___ew "${user_size}" 'G'; then suff='G'
            else
                logerror "wrong value for --size/-s (suffix): ${user_size}"
                exit 1
            fi
            val=$(echo "${val}" | tr "${suff}" ' ') # remove suffix, cheap
            val=$(echo $val)
        fi
    fi
    if ! string_isnumber "${val}"; then
        logerror "wrong value for --size/-s (value): ${user_size}"
        exit 1
    fi
    lognotice "search for SIZE: ""$(echo_red "${pref}${val}${suff}")"

    #rescale all vals to bytes (busysbox find may not understand M, G)
    local real_val=
    real_val="${val}"
    if [ "${suff}" = "c" ] ; then
        true # pass
    elif [ "${suff}" = "k" ] ; then
        real_val=$((real_val*1024))
    elif [ "${suff}" = "M" ] ; then
        real_val=$((real_val*1024*1024))
    elif [ "${suff}" = "G" ] ; then
        real_val=$((real_val*1024*1024*1024))
    fi
    ret_real_size="${pref}${real_val}c"

    # ----------------------------------------
    # return values
    eval "export ${export_var_real_size}='${ret_real_size}'"
    return 0
}
fi

main()
{
    if [ "${CMD_LINE_OPT__UPGRADE}" = "1" ] ; then
        CMD_LINE_OPT__VERBOSE="1"
        export CMD_LINE_OPT__VERBOSE
        CMD_LINE_OPT__DRY="0"
        export CMD_LINE_OPT__DRY
        run_upgrade 'hdfind' "${UPGRADE_LATEST_RELEASE_LINK}" "${UPGRADE_UNIQUE_TOKEN}" 's!^__VERSION__="(.+)"$!\1!p' "${__path__}" "${__file__}"
        exit $? # always exit after upgrade!
    fi


    if [ "${CMD_LINE_OPT__IGNORE_EXCLUDE}" = "1" ] ; then
        FIND_IGNORE_PATTTERNS=
    fi

    lognotice "last result persistence: ${HDGREP_LAST_RESULT_TMP_FILE}"
    lognotice "tools options cache (refresh with: --rescan-tools-opts): ${HDFIND_CTSO_CACHE_TMP_FILE}"

    local ign_info=
    __cIFS '_info_ign_' '
'
    for i in ${FIND_IGNORE_PATTTERNS} ; do
        ign_info="${ign_info} '${i}'"
    done
    __rIFS '_info_ign_'
    lognotice "exclude path patterns: ${ign_info}"


    [ "${CMD_LINE_OPT__DRY}" = "1" ] && {
         echo_red "This is a DRY run. No real search is performed";
         CMD_LINE_OPT__VERBOSE="1";
         }

    local search_in_this_directory=

    local i=
    local color_txt=

    search_in_this_directory="${CMD_LINE_OPT__CHDIR}"
    if ___sw "$search_in_this_directory" "/"; then
        true # pass
    else
        if ___sw "$search_in_this_directory" "./"; then
            true # pass
        else
            search_in_this_directory="./$search_in_this_directory"
        fi
    fi
    if ! ___ew "$search_in_this_directory" "/"; then
        search_in_this_directory="$search_in_this_directory/"
    fi

    # feature checks
    if [ "${CMD_LINE_OPT__IGNORE_CASE}" = "1" ] && [ "${FIND_CAN_INAME}" != "1" ] ; then
        CMD_LINE_OPT__VERBOSE=1
        logerror "'find' does not support -iname (ignore case in names)"
        exit 1
    fi

    # normalize options in case of MD5 search
    local md5_txt="FILE PATTERN(s)"
    if [ "${CMD_LINE_OPT__MD5}" = "1" ] ; then
        md5_txt="FILES have MD5 hash"
        CMD_LINE_OPT__IGNORE_CASE="0"
        CMD_LINE_OPT__EXACT="1"
    fi

    # handle preface
    local show_defaults=
    local show_dirs_only=
    local show_match_only=
    local use_p0="1"
    show_defaults="1"
    show_dirs_only="0"
    show_match_only="0"
    if [ "${CMD_LINE_OPT__SHOW_DIRS_ONLY}" = "1" ]; then
        show_defaults="0"
        show_dirs_only="1"
        show_match_only="1"
    elif [ "${CMD_LINE_OPT__SHOW_MATCH_ONLY}" = "1" ]; then
        show_defaults="0"
        show_dirs_only="0"
        show_match_only="1"
        use_p0="0"
    fi
    if [ "${CMD_LINE_OPT__SHOW_DEFAULTS}" = "1" ]; then
        show_defaults="1"
        show_dirs_only="0"
        show_match_only="0"
    fi
    if [ ${show_dirs_only} = "1" ] && [ "${XARGS_CAN_STRING_REPLACE}" != "1" ] ; then
        logerror "'xargs' does not support -I (Replace STR), cannot run with --show-dirs-only"
        exit 1
    fi

    # search size
    local find_options_size=
    if [ -n "${CMD_LINE_OPT__SIZE}" ]; then
        if [ "${FIND_CAN_SIZE}" = "1" ]; then
            prep_find_size "${CMD_LINE_OPT__SIZE}" REAL_SIZE
            find_options_size="-size ${REAL_SIZE}"
        else
            logwarning "'find' does not support '-size', --size will be ignored"
        fi
    fi

    # search type
    # if nothing is set -> we search for all
    local type_options=
#    if [ "${CMD_LINE_OPT__MD5}" = "1" ] ; then
#        type_options="${type_options} -type f";
#    else
        if [ "${CMD_LINE_OPT__TYPE_FILE}" = "1" ] ; then
            [ -n "${type_options}" ] && type_options="${type_options} -o"
            type_options="${type_options} -type f";
            lognotice "search for TYPE: $(echo_red file)"
        fi
        if [ "${CMD_LINE_OPT__TYPE_DIR}" = "1" ] ; then
            [ -n "${type_options}" ] && type_options="${type_options} -o"
            type_options="${type_options} -type d";
            lognotice "search for TYPE: $(echo_red dir)"
        fi
        if [ "${CMD_LINE_OPT__TYPE_LINK}" = "1" ] ; then
        [ -n "${type_options}" ] && type_options="${type_options} -o"
            type_options="${type_options} -type l";
            lognotice "search for TYPE: $(echo_red link)"
        fi
        if [ "${CMD_LINE_OPT__TYPE_CHARDEV}" = "1" ] ; then
        [ -n "${type_options}" ] && type_options="${type_options} -o"
            type_options="${type_options} -type c";
            lognotice "search for TYPE: $(echo_red chardev)"
        fi

#    fi
    if [ -n "${type_options}" ] ; then
        type_options="\( ${type_options} \)";
    fi

    get_real_find_file_and_grep_patterns "${use_p0}" "${find_options_size}" "${type_options}" REAL_FIND_FILE_PATTERN REAL_GREP_FOR_THIS REAL_FIND_FILE_PATTERN_INFO "$@"
    local find_file_pattern=
    local grep_for_this=
    local find_file_pattern_info=
    find_file_pattern="${REAL_FIND_FILE_PATTERN}"
    grep_for_this="${REAL_GREP_FOR_THIS}"
    find_file_pattern_info=${REAL_FIND_FILE_PATTERN_INFO}

    # handle color
    local color_txt=
    if [ "${GREP_CAN_COLOR}" = "1" ] ; then
        color_txt='--color="always"'
        if [ "${CMD_LINE_OPT__DISABLE_COLOR}" = "1" ]; then
            color_txt=
        fi
    else
        logwarning "'grep' does not support colors"
    fi

    # print some info for user
    if [ "${DO_I_RUN_INTERACTIVELY}" != "1" ]; then
        lognotice "search for ${md5_txt}: ""$(echo_red "${find_file_pattern_info}")"" in DIR ""$(echo_red "\"${search_in_this_directory}\"")"
    else
        lognotice "search for ${md5_txt}: ""$(echo_red "${find_file_pattern_info}")"" in LIST OF PATHS given via ""$(echo_red stdin)"""
        if [ "${SED_SUPPORTS_BINARY_PATTERNS}" != "1" ] ; then
            logwarning "your 'sed' does not support binary patterns, I'll not be able to strip colors from stdin"
        fi
    fi


    #find
    local find_cmd=
    local find_options=

    find_cmd="find"

    if [ "${CMD_LINE_OPT__FOLLOW_SYMLINKS}" = "1" ] ; then
        find_cmd="${find_cmd} -L"
    fi

    # search depth
    if [ -n "${CMD_LINE_OPT__DEPTH}" ]; then
        if [ "${FIND_CAN_MAXDEPTH}" = "1" ]; then
            find_options="${find_options} -maxdepth ${CMD_LINE_OPT__DEPTH}"
        else
            logwarning "'find' does not support '-maxdepth', --depth will be ignored"
        fi
    fi

    local ignore_tmp=
    if [ "${FIND_CAN_WHOLENAME}" = "1" ] && [ "${FIND_CAN_NOT}" = "1" ]; then
        __cIFS '_find_ign_' '
'
        for i in ${FIND_IGNORE_PATTTERNS} ; do
            ignore_tmp=${i}
            ___sw "${ignore_tmp}" "*" || ignore_tmp="*${ignore_tmp}"
            #___ew "${ignore_tmp}" "*" || ignore_tmp="${ignore_tmp}*"
            find_options="${find_options} -not -wholename '${ignore_tmp}'";
        done
        __rIFS '_find_ign_'

    else
        logwarning "'find' does not support '-not -wholename', therefore no search paths can be ignored"
        logwarning "    desired paths to skip: ${FIND_IGNORE_PATTTERNS}"
    fi
    #if [ "${CMD_LINE_OPT__MD5}" != "1" ] ; then
        find_options="${find_options} ${find_file_pattern}";
    #else
        ## in md5 case get them all, let xargs run parallel md5sum
        #true # pass
    #fi
    #[ "${FIND_CAN_PRINT0}" = "1" ] && [ "${XARGS_CAN_0}" = "1" ] && find_options="${find_options} -print0";

    # xargs
    local xargs_cmd=
    local xargs_options=

    xargs_cmd="xargs"
    xargs_options="${xargs_options} -r"

    [ "${FIND_CAN_PRINT0}" = "1" ] && [ "${XARGS_CAN_0}" = "1" ] && xargs_options="${xargs_options} -0";
    [ "${XARGS_CAN_MULTIPROCESS}" = "1" ] && xargs_options="${xargs_options} -P0";

    if [ "${CMD_LINE_OPT__MD5}" = "1" ] ; then
        xargs_options="${xargs_options} md5sum";
    else
        xargs_options="${xargs_options} ls ${color_txt} -ldh";
    fi

    # grep
    local grep_cmd=
    local grep_options=
    export LC_ALL=C

    grep_cmd="grep"
    #[ "${GREP_CAN_FIXEDSTRING}" = "1" ] && grep_options="${grep_options} -F";
    [ "${GREP_CAN_IGNORECASE}"  = "1" ] && grep_options="${grep_options} ${ignore_search_case_for_grep}";
    # important: must be the last one
    [ "${GREP_CAN_EXPLICIT_PATTERN}" = "1" ] && grep_options="${grep_options} -i -e";


    # nl
    local nl_cmd=
    local nl_options=
    if [ "${NL_EXISTING}" = "1" ]; then
        nl_cmd="nl"
        [ "${NL_CAN_NUMBER_WIDTH}" = "1" ] && nl_options="${nl_options} -w 3";
        [ "${NL_CAN_NUMBER_SEPARATOR}" = "1" ] && nl_options="${nl_options} -s ' | '";
    fi

    local cmd=
    local cmd_pre=
    local cmd_post=
    local cmd_pesistence_redirect=
    # find itself
    cmd_pre="${find_cmd} '${search_in_this_directory}' ${find_options}"

    # add infos for user (in case of md5sum search these are neccessary steps)
    if [ "${show_defaults}" = "1" ]; then
        # show type, size access rights, or check md5
        cmd_post="${cmd_post} | ${xargs_cmd} ${xargs_options}"
        # color what user had searched for, with grep
        if [ "${grep_for_this}" != '"."' ] ; then
            cmd_post="${cmd_post} | ${grep_cmd} ${color_txt}${grep_options} ${grep_for_this}"
        fi
        # number results
        [ "${NL_EXISTING}" = "1" ] && cmd_post="${cmd_post} | ${nl_cmd} ${nl_options}"
    else
        # show_match_only
        #if [ "${show_match_only}" = "1" ] ; then
            if [ "${CMD_LINE_OPT__MD5}" = "1" ] ; then
                # in case of md5 search we still need prepared xargs cmd
                cmd_post="${cmd_post} | ${xargs_cmd} ${xargs_options}"
                # then we need to filter relevant and strip sum itself
                cmd_post="${cmd_post} | grep ${grep_for_this}"
                cmd_post="${cmd_post} | sed -r  's![0-9a-z]{32}( +)(.+)!\2!g'"
            else
                if [ "${FIND_CAN_PRINT0}" = "1" ] && [ "${XARGS_CAN_0}" = "1" ]; then
                    if [ "${show_dirs_only}" = "1" ] ; then
                        # use xargs to show dirs only
                        # escape " and $ within sh -c ''
                        cmd_post="${cmd_post} | ${xargs_cmd} -0 -n1 -I '_p1' sh -c '_f(){ i=\$1; echo \"\${i%/*}\" || echo \"\$1\";}; _f \"_p1\"' | sort | uniq"
                    else
                        cmd_post="${cmd_post}"
                    fi
                else
                    # find will run normally, no xargs is invoked
                    if [ "${show_dirs_only}" = "1" ] ; then
                        # use xargs to show dirs only
                        # escape " and $ within sh -c ''
                        cmd_post="${cmd_post} | ${xargs_cmd} -n1 -I '_p1' sh -c '_f(){ i=\$1; [ ! -d \"\$1\" ] && echo \"\${i%/*}\" || echo \"\$1\";}; _f \"_p1\"'"
                    fi
                fi
            fi
        #fi
    fi

    # redirect output to tmpfile, using last search results in other tools
    if [ "${show_defaults}" = "1" ] && [ -n "${HDGREP_LAST_RESULT_TMP_FILE}" ]; then
        cmd_pesistence_redirect=" | tee '${HDGREP_LAST_RESULT_TMP_FILE}'"
    fi

    if [ "${DO_I_RUN_INTERACTIVELY}" != "1" ]; then
        cmd="${cmd_pre}${cmd_post}${cmd_pesistence_redirect}"
        if [ -n "${WIN_CMD_ROOT}" ]; then
            lognotice "(real cmd): sh -c \"${cmd}\""
        else
            lognotice "(real cmd): ${cmd}"
        fi
        run "$cmd"
    else
        # we get data from a pipe, assume this is a list of paths, where we should search
        while read -r one_line_from_stdin ; do
            one_line_from_stdin=$(strip_colors "${one_line_from_stdin}")
            lognotice "find in: '${one_line_from_stdin}' ..."

            cmd_pre="${find_cmd} '${one_line_from_stdin}' ${find_options}"
            cmd="${cmd_pre}${cmd_post}${cmd_pesistence_redirect}"
            if [ -n "${WIN_CMD_ROOT}" ]; then
                lognotice "(real cmd): sh -c \"${cmd}\""
            else
                lognotice "(real cmd): ${cmd}"
            fi
            run "${cmd}"
        done
    fi
    return 0
}
if [ "${__name__}" = "__main__" ] ; then
    main "$@"
    exit $?
fi

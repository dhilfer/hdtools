#!/bin/sh
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License 3 as published
# by the Free Software Foundation.
# THERE IS NO ANY WARRANTY AT ALL

__sr_RUN_STRICT=1
if true; then # ___srV="2.9.12"
___cvs(){ [ -z "$1" ] && { echo 0;return;};[ -z "$2" ] && { echo 1;return;};local _e8=;local _Uc=;local _mZ=;for _e8 in 1 2 3 4 5;do _Uc=$(eval "echo $1 | cut -d "." -f$_e8");_mZ=$(eval "echo $2 | cut -d "." -f$_e8");[ -z "$_Uc" ] && [ -z "$_mZ" ] && { echo 0;return;};[ -z "$_Uc" ] && { echo -1;return;};[ -z "$_mZ" ] && { echo 1;return;};diff=$((_Uc-_mZ));[ $diff -ne 0 ] && { [ $diff -le 0 ] && echo -1 || echo 1;return;};done;echo 0;};if [ "$(___cvs 2.9.10 $___srV )" = 1 ]; then [ -z "$___srD" ] && ___srD=0;___rp(){ eval 'readlink -f "'$1'" 2>/dev/null';};__is_win__=0;[ -n "$APPDATA" ] && __is_win__=1;[ -n "$CMDER_ROOT" ] && WIN_CMD_ROOT=$(___rp "${CMDER_ROOT}");___type(){ [ -n "$2" ] && eval "export $2=";local _r=;local _t=;_t=$(LANG=C command -pV "${1}" 2>/dev/null);if [ "$?" != "0" ];then _r=$(which "${1}" 2>/dev/null);[ -z "${_r}" ] && return 1;fi;if [ -z "${_r}" ];then case "$_t" in *function*) _r=function;; *builtin*) _r=builtin;; *alias*) _r=alias;; *) _r=$(command -v ${1} 2>/dev/null);; esac;fi;[ -n "$2" ] && eval "export $2='$_r'";return 0;};___sw(){ case "$1" in "$2"*) return 0;;esac;return 1;};___ew(){ case "$1" in *"$2") return 0;;esac;return 1;};echo_stderr(){ echo "$@" >&2;};___sw "$(echo -e t)" "-e" || { alias echo="echo -e"; echo_stderr(){ echo -e "$@" >&2;};};__get_linenr(){ local _sd=0;[ -n "$1" ] && _sd=$1;[ "$__is_bbash__" = "1" ] && eval echo '${''BASH_LINENO['${_sd}']''}';};_chkargs(){ local fn=;local nr=;fn="$1";nr="$2";shift 2;[ ! $# -eq $nr ] && { echo_stderr "(sr) $__path__/$__file__:$(__get_linenr 2) $fn(): needs $nr arg(s), $# given";exit 1;};};_chkargsm(){ local fn="$1";local nr="$2";shift 2;[ ! $nr -le $# ] && { echo_stderr "(sr) $__path__/$__file__:$(__get_linenr 2) $fn(): needs at least $nr arg(s), $# given";exit 1;};};__DIFS=$IFS;__rdIFS(){ IFS=$__DIFS; };__cIFS(){ _chkargs '__cIFS' 2 "$@";local __oifs=; __oifs="${1}__oifs";eval "export ${__oifs}='$IFS'";IFS=$2;};__rIFS(){ _chkargs '__rIFS' 1 "$@";local __oifs=; __oifs="${1}__oifs";eval 'IFS="${'"${__oifs}"'}"';};IN(){ local __i=;local __r=1;[ -n "$3" ] && __cIFS 'IN' "$3";for __i in $2;do [ "$1" = "$__i" ] && { __r=0;break;};done;[ -n "$3" ] && __rIFS 'IN';return $__r;};run(){ [ "$DBG_RUN" = "1" ] && echo_stderr "$([ "$DRY_RUN" = "1" ] && echo "(dry)")run: $@"; [ "$DRY_RUN" = "1" ] && return 0; eval "$@";return $?;};run_e(){ echo_stderr "$([ "$DRY_RUN" = "1" ] && echo "(dry)")run: $@"; [ "$DRY_RUN" = "1" ] && return 0; eval "$@";return $?;};add_sr_PATH(){ ! IN "$1" "${sr_PATH}" ":" && export sr_PATH="${1}:${sr_PATH}";};__is_bbash__=0;__is_bash__=0;[ -n "$BASH" ] && { __is_bbash__=1; shopt -s expand_aliases;};[ -z "${__name__}" ] &&  [ "$__is_bbash__" = "0" ] && [ "${__sr_RUN_STRICT}" != "1" ] && [ -n "$(command -pv bash)" ] && { [ $___srD = 1 ] && echo_stderr "(sr) relocate to bash (disable it with: __sr_RUN_STRICT=1)";$(command -v bash) "$0" "$@"; exit $?; }; ___ew "$BASH" "bash" && { __is_bash__=1;};__is_dbg__=0;[ $__is_bash__ = 1 ] && [ -n "$_Dbg_DEBUGGER_LEVEL" ] && __is_dbg__=1; __pid__=$$;__cwd__=$(pwd);fi;__name__=;_az=;if [ -n "$__sr_inc_rp" ];then _az=$__sr_inc_rp; unset __sr_inc_rp;else if [ -z "$__main__" ];then __name__=__main__;export __modules__=;fi;[ "$__is_bbash__" = "1" ] && _az=$(___rp '${''BASH_SOURCE[0]''}');[ -z "$_az" ] && _az=${0};fi;__f_path__=$(___rp "${_az}");[ -n "$__HDBDB_RP_" ] && { __f_path__=$__HDBDB_RP_; export __HDBDB_RP_=;};__path__=${__f_path__%/*};__file__=${__f_path__##*/};__ns__=${__file__%.*};[ "$__name__" != "__main__" ] && { __name__=$__main__; __main__=$__main__;} || { __main__=$__file__;};_az=;add_sr_PATH "$__path__";if [ "$(___cvs 2.9.10 $___srV )" = 1 ]; then __require(){ [ "$2" != "1" ] && IN "$1" "$__modules__" ":" && { [ $___srD = 1 ] && echo_stderr "(sr) $__path__/$__file__:$(__get_linenr 2) require(): '$1': is already loaded, skip"; return; };local __nm=;local __sp=;local __sf=;local __sn=;local __sz=;[ -n "$__f_path__" ] && { __nm=$__name__;__sz=$__f_path__;__sp=$__path__;__sf=$__file__;__sn=$__ns__;};export __modules__="$1:$__modules__";export __sr_inc_rp=$1;[ $___srD = 1 ] && echo_stderr "(sr) $__path__/$__file__:$(__get_linenr 2) require(): '$1'";. "$1";unset __sr_inc_rp;[ -n "$__sz" ] && { __name__=$__nm;__f_path__=$__sz;__path__=$__sp;__file__=$__sf;__ns__=$__sn;};[ $___srD = 1 ] && echo_stderr "(sr) $__path__/$__file__:$(__get_linenr 2) require(): '$1': successfully loaded";};require(){ local __pp=;local __rip=;if ! ___sw "$1" "/";then __cIFS 'require' ':';for __pp in $sr_PATH;do [ -e "${__pp}/${1}" ] && { __rip="${__pp}/${1}"; break;};[ -e "${__pp}/${1}.sh" ] && { __rip="${__pp}/${1}.sh"; break;};done;__rIFS 'require';[ -z "$__rip" ] && { echo_stderr "(sr) $__path__/$__file__:$(__get_linenr 1) require(): '$1': module not found [ sr_PATH=$sr_PATH ]";exit 1;};else __rip=$1;[ ! -e "$__rip" ] && { echo_stderr "(sr) $__path__/$__file__:$(__get_linenr 1) require(): '$1': module not found (absolute path)"; exit 1;};fi;__rip=$(___rp "${__rip}");__require "${__rip}" $2; __pp=;__rip=;};fi;if [ "$(___cvs 2.9.10 $___srV )" = 1 ]; then ___srV="2.9.10";[ $___srD = 1 ] && echo_stderr "(sr) $__path__/$__file__ (___srV: $___srV)";else [ $___srD = 1 ] && echo_stderr "(sr) $__path__/$__file__ (___srV: 2.9.10): current ___srV: $___srV env has higher/equal version than I, skip redefine"; fi;__tab='	';__newline='
';fi

[ -n "$(echo "$@" | sed -nr 's!(--dry)!\1!p')" ] || [ -n "$(echo "$@" | sed -nr 's!(--verbose)!\1!p')" ] && { export __log_trace__=1; export __log_no_main__=0; export DBG_RUN=1;export TMP_DEBUG="true";export __sr_TMP_DEBUG=1;} # ___srD=1; # verbose: 1.1.9, dry implies verbose
[ -n "$(echo "$@" | sed -nr 's!(--dry)!\1!p')" ] && { export DRY_RUN=1;}
[ -z "${TERM}" ] && __sr_DISABLE_COLOR=1

if true; then                                                           # escape %APPDATA% on windows
# hacky fix %APPDATA% path on windows, escape backslashes '\\'
# add extra level of escaping '\\\\\\\\' instead of '\\\\', will allow us to do nicier logXXX calls
[ "$__is_win__" = "1" ] && APPDATA=$(env | grep ^APPDATA= | sed -r  's!\\!\\\\\\\\!g' | sed -r  's!APPDATA=!!g')
# this one works too within sh, but for evt. echo's its more convinient to use the one above
#[ "$__is_win__" = "1" ] && APPDATA=$(env | grep ^APPDATA= | tr '\\' '//' | sed -r  's!APPDATA=!!g')
fi

# this is hdfind: find stuff with increased usability
# 2008-2021: Dieter Hilfer
# the zen of hdfind:
#   - be one file-tool
#   - run on sh, bash, busybox-sh, windows mingw/git-like environments
#   - do not use persistence (except for intermediate helper):
#       - HDFIND_ENABLE_KEEP_LAST_RESULT
#       - HDFIND_ENABLE_TOOL_FEATURE_CACHE
#     which can easily be disabled
#   - exec speed is not as important, as usability (and code maintainability)

__VERSION__="7.9.24"

BASIC_USAGE="(${__VERSION__}): hdfind [-C search_dir] [OPTIONS(--help to show)] [--] PATTERN [PATTERN PATTERN ...]"

# control persistence here
HDFIND_ENABLE_KEEP_LAST_RESULT=1
# this will save you A LOT of time while startup on Windows
HDFIND_ENABLE_TOOL_FEATURE_CACHE=1

# ignore search here by default
FIND_IGNORE_PATTTERNS='
/.svn/*
/.git/*
/.cmake/*
/__pycache__/*
'

if true; then                                                           # grep color scheme
COLOR_SCHEME_GREP_HD='ms=43;31:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=' #1.0.1
COLOR_SCHEME=${COLOR_SCHEME_GREP_HD}
export GREP_COLORS=${COLOR_SCHEME}
fi
if true; then                                                           # base: 3.1.6           # MODIFIED: lognotice, loginfo to stderr, logdebug without colors
if true; then                                                           # base:colors: 1.2.2
# __sr_DISABLE_COLOR: 0
# 1st: parm may be:
#    <b>: bold
#   <bg>: background+bold
__echo_col() { local _clr=; _clr=${1}; shift 1; local _bld=; local _grd=3; [ "${1}" = "<b>" ] && { _bld="1;"; shift 1; }; [ "${1}" = "<bg>" ] && { _bld="1;";_grd=4; shift 1; }; [ "${__sr_DISABLE_COLOR}" = "1" ] && echo "${@}" || echo "\033[${_bld}${_grd}${_clr}m${@}\033[0m" ; }
echo_red()      { __echo_col 1 "${@}"; }
echo_green()    { __echo_col 2 "${@}"; }
echo_yellow()   { __echo_col 3 "${@}"; }
echo_magenta()  { __echo_col 5 "${@}"; }
echo_grey()     { __echo_col 0 "<b>" "${@}"; }

echo_blue()      { __echo_col 4 "${@}"; }
echo_lightblue() { __echo_col 6 "${@}"; }
echo_bold()      { [ "${__sr_DISABLE_COLOR}" != "1" ] && echo "\033[1m${@}\033[0m" || echo "$@"; }
fi
# (c)heck var is (s)et in (e)nvironment
_csE() { [ -z "${1}" ] && return 1;[ -z "$(eval echo "$""${1}")" ] && return 1 || return 0;}
# (c)heck var is (s)et in (e)nvironment or set to default #(env_var, def_val, !echo_var=0)
_cse() { { [ -z "$(eval echo "$""${1}")"  ] && export "${1}=${2}";}; val=$(eval echo "$""${1}"); [ "${3}" = "1" ] && _logdebug 2 "ENV: $(echo_green "${1}")=${val}";}
if true; then                                                           # base:log: 1.5.0       # requires: colors, _cse
_cse __log_no_facility__ 0           # default:  0, don't show log facilities ("notice", "error", ...)
_cse __log_no_notice_facility__ 1    # default:  0, don't show log facilities above "notice", show the rest beyond (error, warning)
_cse __log_date__ 0                  # default:  0, show timestamp # append .%N nanoseconds if target date supports this manually below
_cse __log_trace__ 0                 # default:  0, show logdebug(), real file:line [ base bash capability required ] (bash, sh->bash)
_cse __log_pid__ 0                   # default:  0, show process pid(as set by _sr to __pid__)
_cse __log_no_main__ 1               # default:  0, don't show __main__ tool name
_cse __log_to_logfile__ 0            # default:  0, don't use logger to log to logfiles
_cse __log_logger_options__ ""       # default: "", pass these additional options to logger

_cse __log_script_line_offset__ 0    # default:  0, passed by run_script_ontarget, run_script_in_chroot
_cse __log_remote_host__    ""       # default: "", passed by run_script_ontarget/hdontarget (if set, show additional 'remote' facility)
_cse __log_remote_user__    ""       # default: "", passed by run_script_ontarget/hdontarget

[ "${__is_bbash__}" != "1" ] && [ "${__log_trace__}" = "1" ] && echo_stderr $(echo_grey "___sr: __log_trace__ is active, to see line numbers you must run in 'bash' or 'sh->bash'")
__log_preface(){
echo \
$([ x${__log_date__} = x1 ] && date +'%Y-%m-%d %H:%M:%S:')\
"$([ x${__log_no_facility__} != x1 ] && [ -n "${2}" ] && echo "${2} ")"\
$([ x${__log_no_main__} != x1 ] && echo_magenta ${__main__})\
$([ x${__log_no_main__} != x1 ] && echo :)\
$([ x${__is_bbash__} = x1 ] && [ x${__log_trace__} = x1 ] && {\
    [ "$(eval echo '${''BASH_SOURCE['$((${1}+1))']''##*/''}')" != "${__main__}" ] && {\
            echo "($(echo_magenta $(eval echo '${''BASH_SOURCE['$((${1}+1))']''##*/''}')):$(echo_green $(($(eval echo '${''BASH_LINENO['${1}']''}')+${__log_script_line_offset__})))):";\
        } || {\
            echo "$(echo_green $(($(eval echo '${''BASH_LINENO['${1}']''}')+${__log_script_line_offset__}))):";\
        };\
})\
$([ -n "${__log_remote_host__}" ] && echo "[$(echo_magenta ${__log_remote_user__}@${__log_remote_host__})]:")\
$([ x${__log_pid__} = x1 ] && echo "($(echo_lightblue "pid: ${__pid__}")):")\
"$([ x${__log_no_main__} != x1 ] && echo ' ')"\
;}
_logerror()  { [ "${__sr_DSBL_ERR}" ] && return; local __d=; __d=${1}; shift 1; echo_stderr "$(__log_preface ${__d}       "$(echo_red '  [error]:')")$(echo_red "$@")";       [ "${__log_to_logfile__}" = 1 ] && logger -p 3 ${__log_logger_options__} -- "${__main__}: $@"; return 0;}
_logwarning(){ [ "${__sr_DSBL_WARN}" ] && return; local __d=; __d=${1}; shift 1; echo_stderr "$(__log_preface ${__d}    "$(echo_yellow '[warning]:')")$(echo_yellow "$@")";    [ "${__log_to_logfile__}" = 1 ] && logger -p 4 ${__log_logger_options__} -- "${__main__}: $@"; return 0;}
_logdebug()  { [ "${__sr_DSBL_DBG}" ] && return; local __d=; __d=${1}; shift 1; echo_stderr "$(__log_preface ${__d}           "$(echo '  [debug]:')")$(echo "$@")";           [ "${__log_to_logfile__}" = 1 ] && logger -p 7 ${__log_logger_options__} -- "${__main__}: $@"; return 0;}
if [ "${__log_no_notice_facility__}" = "1" ] && [ "${__log_trace__}" != 1 ] ; then
_lognotice() { [ "${__sr_DSBL_NTCE}" ] && return; local __d=; __d=${1}; shift 1; echo_stderr "$(__log_preface ${__d}           "")$(echo "$@")";           [ "${__log_to_logfile__}" = 1 ] && logger -p 5 ${__log_logger_options__} -- "${__main__}: $@"; return 0;}
_loginfo()   { [ "${__sr_DSBL_INFO}" ] && return; local __d=; __d=${1}; shift 1; echo_stderr "$(__log_preface ${__d}           "")$(echo_lightblue "$@")";        [ "${__log_to_logfile__}" = 1 ] && logger -p 6 ${__log_logger_options__} -- "${__main__}: $@"; return 0;}
else
_lognotice() { [ "${__sr_DSBL_NTCE}" ] && return; local __d=; __d=${1}; shift 1; echo_stderr "$(__log_preface ${__d}           "$(echo ' [notice]:')")$(echo "$@")";           [ "${__log_to_logfile__}" = 1 ] && logger -p 5 ${__log_logger_options__} -- "${__main__}: $@"; return 0;}
_loginfo()   { [ "${__sr_DSBL_INFO}" ] && return; local __d=; __d=${1}; shift 1; echo_stderr "$(__log_preface ${__d} "$(echo_lightblue '   [info]:')")$(echo_lightblue "$@")";        [ "${__log_to_logfile__}" = 1 ] && logger -p 6 ${__log_logger_options__} -- "${__main__}: $@"; return 0;}
fi
logerror()   { _logerror   2 "$@";}
logwarning() { _logwarning 2 "$@";}
logdebug()   { _logdebug   2 "$@";}
loginfo()    { _loginfo    2 "$@";}
lognotice()  { _lognotice  2 "$@";}

# redefine run, for fancier backtrace logging
[ "${__log_trace__}" = "1" ] && run() { [ "${DBG_RUN}" = "1" ] && { _logdebug  2 "$([ "${DRY_RUN}" = "1" ] && echo "(dry)")run: $@" ;}; [ "${DRY_RUN}" = "1" ] && return 0; eval "$@";return $?;}
# always redefine run_e, if log is available
run_e() { _lognotice 2 "$([ "${DRY_RUN}" = "1" ] && echo "(dry)")run: $@"; [ "${DRY_RUN}" = "1" ] && return 0; eval "$@";return $?;}
# no trace -> no debug
[ "${__log_trace__}" != "1" ] && _logdebug(){ true; } # pass
fi
if true; then                                                           # base:checks: 1.1.7    # requires: log
#(reason, !exit_code=1, !stack_depth=2)
die() { local err=1;local _dd=2;[ -n "${2}" ] && err=${2};[ -n "${3}" ] && _dd=${3};_logerror ${_dd} "${1}";exit ${err};}
_cca() { die "_cca() is DEPRECATED, use ___type() from ___srV>='2.9.4' instead" ; }

# (c)heck (ex)ists #(path)
_cex() { [ -e "${1}"  ] || { _logwarning 2 "${1}: does not exist" ; return 1 ; } }
# (c)heck path (ex)ists or (d)ie #(path, !add_err_txt="", !err_code)
_cex_d() { local err=; [ -n "${3}" ] && err=${3}; [ ! -e "${1}" ] && { die "'${1}': path does not exist${2}" "${err}" 3;};}

# (c)heck is (Ex)ecutable #(cmd)
_cEx() { [ -x "${1}"  ] || { _logwarning 2 "${1}: is not a executable" ; return 1 ; } }
# (c)heck is (Ex)ecutable or (d)ie #(cmd, !add_err_txt="", !err_code)
_cEx_d() { local err=; [ -n "${3}" ] && err=${3}; [ ! -e "${1}" ] && { die "'$1': is not a executable${2}" "${err}" 3;};}

# check os tools
_cet() { local _T=;local _A=;_T=$(echo "${1}" | cut -d":" -f1);_A=$(echo "${1}" | cut -d":" -f2);[ -n "$(which ${_T})"  ] || { logwarning "required tool: '${_T}': was not found. try to install it with: 'sudo apt install ${_A}', or so"; return 1 ; } ; }
_ct() { local ret=; local i; ret=0; for i in ${1} ; do _cet "${i}"; ret=$?; if [ "${ret}" != "0" ]; then ret=${ret}; fi; done; if [ "${ret}" != "0" ]; then  die "-" 1 3; fi; }
#_tools='convert:imagemagick
#ppmquant:netpbm'
#_ct "${_tools}"

# (e)cho (e)nvironment (v)ar  #(env_var, !add_txt="")
_eev() { local val=; val=$(eval echo "$""${1}"); _lognotice 2 "ENV: $(echo_green "${1}")=${val}${2}";}
# (s)et (e)nvironment with (e)cho  #(env_var, val)
_see() { export "${1}=${2}"; _lognotice 2 "ENV: $(echo_green "${1}")=${2}";}
# (c)heck var (s)et in (e)nvironment or (d)ie #(env_var, !add_err_txt="", !echo_var_if_ok=0, !err_code)
_cse_d() { local err=; [ -n "${4}" ] && err=${4}; [ -z "$(eval echo "$""${1}")"  ] && { die "${1}: is not set in env${2}" "${err}" 3;} || { [ "${3}" = "1" ] && { val=$(eval echo "$""${1}"); _logdebug 2 "ENV: $(echo_green "${1}")=${val}";};};}

# (c)heck (i)s (r)oot or (d)ie #()
_cir_d() { if [ "$(id -u)" != "0" ] ; then die "You must be root to proceed" "" 3; fi;}
# (c)heck (n)ot (r)oot or (d)ie #()
_cnr_d() { if [ "$(id -u)" = "0" ] ; then die "You must NOT be root to proceed" "" 3; fi;}
fi
fi
if true; then                                                           # strips
# sed must support binary patterns (some busybox sed does not)
SED_SUPPORTS_BINARY_PATTERNS=0; [ -z "$(echo "1" | sed -r 's!([0-9]+)!\x1b[32m\1\x1b[0m!g' | grep x1b)" ] && SED_SUPPORTS_BINARY_PATTERNS=1
if [ "${SED_SUPPORTS_BINARY_PATTERNS}" = "1" ] ; then
    # fancy colors max 6groups to drop
    strip_colors() { echo "$@" | sed -r 's/\x1B\[([0-9]{1,2}(;[0-9]{1,3}(;[0-9]{1,3}(;[0-9]{1,3}(;[0-9]{1,3}(;[0-9]{1,3})?)?)?)?)?)?[mGK]//g' ; }
else
    strip_colors() { echo "$@"; }
fi
lstrip_lines() { echo "${@}" | sed -e 's/^[[:space:]]*//'; }
rstrip_lines() { echo "${@}" | sed -e 's/[[:space:]]*$//'; }
strip_lines() { echo "${@}" | sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$//'; }
fi
if true; then                                                           # persistence setup
_handle_pers_setup()
{
    if [ -n "${WIN_CMD_ROOT}" ]; then
        # we are on Windows
        HDGREP_LAST_RESULT_TMP_FILE="${APPDATA}\\\\hdgrep.last_result"
        HDFIND_CTSO_CACHE_TMP_FILE="${APPDATA}\\\\hdfind.ctso"
    else
        local _xpref="/tmp/"
        if [ -n "${XDG_RUNTIME_DIR}" ] ; then
            # try work with XDG tmpfs
            _xpref="${XDG_RUNTIME_DIR}"
        fi
        HDGREP_LAST_RESULT_TMP_FILE="${_xpref}/hdgrep.$(whoami).last_result"
        HDFIND_CTSO_CACHE_TMP_FILE="${_xpref}/hdfind.ctso"
    fi


    [ "${HDFIND_ENABLE_KEEP_LAST_RESULT}" != "1" ] && HDGREP_LAST_RESULT_TMP_FILE=
    [ "${HDFIND_ENABLE_TOOL_FEATURE_CACHE}" != "1" ] && { HDFIND_CTSO_CACHE_TMP_FILE= ; }
}
_handle_pers_setup
fi
if true; then                                                           # options
# MODIFIED: # extends FIND_IGNORE_PATTTERNS, pretty usage, extended comment at [ "${broken_opts}" = "1" ]
print_usage()
{
    # options
    echo "${BASIC_USAGE}

Search for FILES, DIRS, LINKS, etc. matching '*PATTERN*' in name.
If given, standard input (stdin) is interpreted as a LIST OF PATHS to
search in.

hdfind is a friendly wrapper for find (utilizing more tools such as:
grep, xargs, [ls, nl, tee, cut, md5sum, wget])

If running first time hdfind will scan supported features of used tools.
Something like: can grep produce colored output? The result will be
cached, and reloaded on later runs.
The cache file is normally stored under a volatile tmp/, so after reboot
a rescan is done again. This ensures cache/tool-feature updates  once in
a while. You can force immediate rescan by using: --rescan-tools-opts

If hdfind does not behave like you expect, maybe you should rerun with
--verbose/-v flag to see useful messages and the real find command.

[OPTIONS]:
  -h      --help              this help
          --rescan-tools-opts reset tools options cache and rescan
                              supported tools features (use with
                              --verbose/-v flag to see more details)


------------ SEARCH RELATED OPTIONS --------------

  -C      --chdir DIR         change directory before starting search

  -i      --ignore-case       ignore word case
  -E      --exact             search for 'PATTERN', not for '*PATTERN*'
  -md5    --md5               PATTERN is an MD5 hash


  -tf     --type-file         search for files
  -td     --type-dir          search for directories
  -tl     --type-link         search for symbolic links
  -tc     --type-chardev      search for char devices


  -e      --exclude-path PATH You can specify multiple path patterns
                              which should be excluded from search.
                              (e.g: -e '/.build' -e '/.cmake')
                              hdfind presets some paths like /.svn,
                              ./git etc. Show them using --verbose/-v
                              option. To disable exclude paths use
                              -J/--ignore-exclude option.
  -J      --ignore-exclude    Ignore all specified and predefined
                              -e/--exclude-paths

  -d      --depth DEPTH       stop search at DEPTH
  -s      --size [+|-]N[ckMG] consider file SIZE N (integer only):
                              Following suffixes can be used:
                                'c':B, 'k':kB, 'M':MB  [default], 'G':GB

                              The + and - [default] prefixes signify
                              greater than and less than.
                              (e.g: -s 5: find files with less than 5MB,
                                    -s +3G: find files greater than 3GB)


------------ DISPLAY RESULTS OPTIONS -------------

Choosing one of the following --show-X-only options  might be helpful to
pipe hdfind  results to  other  tools (e.g.: grep).  It will also advice
hdfind NOT to store last search results in a tmp file (currently):
  ${HDGREP_LAST_RESULT_TMP_FILE}

  -sm     --show-match-only   show matching RESULTS only
  -sd     --show-dirs-only    show DIRS  containing match  PATTERNS only
  -D      --show-defaults     force  default  show behaviour  (overrides
                              any --show-X-only)
hdfind will try  to force  colored output  on every search. However from
time to time it's more convinient to disable colors (e.g. on output
redirection)
  -dc     --disable-color     disable colored output


------------ OTHER OPTIONS -----------------------

  -dry    --dry               show  calls only, don't perform any search
  -v      --verbose           print messages (which may help you to
                              analyze hdfind's behaviour)
          --upgrade           try to upgrade  hdfind to latest version,
                              using one of following links:
${UPGRADE_LATEST_RELEASE_LINKS}
"
}

CMD_LINE_OPT__RESCAN_TOOLS_OPTS="0"  # -
CMD_LINE_OPT__IGNORE_CASE="0"  # -
CMD_LINE_OPT__EXACT="0"  # -
CMD_LINE_OPT__MD5="0"  # -
CMD_LINE_OPT__TYPE_FILE="0"  # -
CMD_LINE_OPT__TYPE_DIR="0"  # -
CMD_LINE_OPT__TYPE_LINK="0"  # -
CMD_LINE_OPT__TYPE_CHARDEV="0"  # -
CMD_LINE_OPT__DEPTH=""  # -
CMD_LINE_OPT__SIZE=""  # -
CMD_LINE_OPT__CHDIR="./"  # -
CMD_LINE_OPT__EXCLUDE_PATH=""  # -
CMD_LINE_OPT__FOLLOW_SYMLINKS="0"  # -
CMD_LINE_OPT__SHOW_MATCH_ONLY="0"  # -
CMD_LINE_OPT__SHOW_DIRS_ONLY="0"  # -
CMD_LINE_OPT__SHOW_DEFAULTS="0"  # -
CMD_LINE_OPT__DISABLE_COLOR="0"  # -
CMD_LINE_OPT__VERBOSE="0"  # -
CMD_LINE_OPT__DRY="0"  # -
CMD_LINE_OPT__IGNORE_EXCLUDE="0"  # -
CMD_LINE_OPT__UPGRADE="0"  # -
CMD_LINE_OPT__RESCAN_TOOLS_AND_SUPPORTED_OPTIONS="0"  # -
parse_all_options()
{
    local shifted=
    shifted=0
    local broken_opts=
    while [ "$#" -gt 0 ]; do
        case "${1}" in
            --)
            # end of option list
                shift 1; shifted=$((shifted+1))
                break;;
            --help|-h)
                print_usage; exit 0;;
            # -
            --rescan-tools-opts)
                CMD_LINE_OPT__RESCAN_TOOLS_OPTS="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --ignore-case|-i)
                CMD_LINE_OPT__IGNORE_CASE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --exact|-E)
                CMD_LINE_OPT__EXACT="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --md5|-md5)
                CMD_LINE_OPT__MD5="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --type-file|-tf)
                CMD_LINE_OPT__TYPE_FILE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --type-dir|-td)
                CMD_LINE_OPT__TYPE_DIR="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --type-link|-tl)
                CMD_LINE_OPT__TYPE_LINK="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --type-chardev|-tc)
                CMD_LINE_OPT__TYPE_CHARDEV="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --depth|-d)
                CMD_LINE_OPT__DEPTH="$2"
                [ $# -lt 2 ] || [ "$2" = "--" ] && { echo "--depth|-d needs an additional parameter" >&2; exit 1; };
                shift 2; shifted=$((shifted+2));;
            # -
            --size|-s)
                CMD_LINE_OPT__SIZE="$2"
                [ $# -lt 2 ] || [ "$2" = "--" ] && { echo "--size|-s needs an additional parameter" >&2; exit 1; };
                shift 2; shifted=$((shifted+2));;
            # -
            --chdir|-C)
                CMD_LINE_OPT__CHDIR="$2"
                [ $# -lt 2 ] || [ "$2" = "--" ] && { echo "--chdir|-C needs an additional parameter" >&2; exit 1; };
                shift 2; shifted=$((shifted+2));;
            # -
            --exclude-path|-e)
                CMD_LINE_OPT__EXCLUDE_PATH="$2"
                [ $# -lt 2 ] || [ "$2" = "--" ] && { echo "--exclude-path|-e needs an additional parameter" >&2; exit 1; };

                # extend FIND_IGNORE_PATTTERNS
                FIND_IGNORE_PATTTERNS="${FIND_IGNORE_PATTTERNS}
${CMD_LINE_OPT__EXCLUDE_PATH}"

                shift 2; shifted=$((shifted+2));;
            # -
            --follow-symlinks|-L)
                CMD_LINE_OPT__FOLLOW_SYMLINKS="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --show-match-only|-sm)
                CMD_LINE_OPT__SHOW_MATCH_ONLY="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --show-dirs-only|-sd)
                CMD_LINE_OPT__SHOW_DIRS_ONLY="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --show-defaults|-D)
                CMD_LINE_OPT__SHOW_DEFAULTS="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --disable-color|-dc)
                CMD_LINE_OPT__DISABLE_COLOR="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --verbose|-v)
                CMD_LINE_OPT__VERBOSE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --dry|-dry)
                CMD_LINE_OPT__DRY="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --ignore-exclude|-J)
                CMD_LINE_OPT__IGNORE_EXCLUDE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --upgrade)
                CMD_LINE_OPT__UPGRADE="1"
                shift 1 ; shifted=$((shifted+1));;
            # -
            --rescan-tools-and-supported-options)
                CMD_LINE_OPT__RESCAN_TOOLS_AND_SUPPORTED_OPTIONS="1"
                shift 1 ; shifted=$((shifted+1));;
            -*)
              echo "unknown option: $1" >&2
              broken_opts=1
              shift 1;;
            *)
              # options parse done
              break ;;
      esac
    done

    [ "${broken_opts}" = "1" ] && { echo "run with --help to see available options" >&2; exit 1; };

    return ${shifted}
}
# parse early
parse_all_options "$@"
shift $?
if [ "${CMD_LINE_OPT__DISABLE_COLOR}" = "1" ]; then
    echo_yellow() { echo "$@"; }
    echo_red()    { echo "$@"; }
fi
fi
if true; then                                                           # get running conditions
# echo "/path/to/file" | hdfind file
DO_I_RUN_INTERACTIVELY=
_get_running_conditions_simple()
{
    if [ ! -t 0 ] ; then DO_I_RUN_INTERACTIVELY="1" ; fi
}
_get_running_conditions_simple
#echo "DO_I_RUN_INTERACTIVELY: $DO_I_RUN_INTERACTIVELY"
fi
if true; then                                                           # _csto: v2.0.2
_ctso_prev_tool=
_ctso_prev_cache=
_ctso_pers_cache_path="$HDFIND_CTSO_CACHE_TMP_FILE"
_ctso_pers_cache_loaded=0
_ctso() #(tool, option_regex, *feature, [ignore_cache="0", check_opt="--help"])
{
    local __fn='_ctso'; _chkargsm ${__fn} 3 "$@"

    local tool=
    local option_regex=
    local export_var_feature=
    local ignore_cache=
    local check_opt=
    tool="${1}"
    option_regex="${2}"
    export_var_feature="${3}" ; eval "export ${export_var_feature}"
    ignore_cache="${4}"
    check_opt="${5}"

    [ -z "${ignore_cache}" ] && ignore_cache=0
    [ -z "${check_opt}" ] && check_opt="--help"

    # ----------
    local ret_feature=

    # ----------------------------------------

    if [ "${ignore_cache}" = "0" ] && [ "${_ctso_pers_cache_loaded}" = "0" ] && [ -n "${_ctso_pers_cache_path}" ] ; then
        # try load persistence cache once
        [ -e "${_ctso_pers_cache_path}" ] && . "${_ctso_pers_cache_path}"
        _ctso_pers_cache_loaded=1
    fi
    if [ "${ignore_cache}" = "0" ] && [ -n "$(eval echo "$""$export_var_feature")"  ]; then
        return 0;
    fi

    ret_feature=0
    local ret=

    if [ "${_ctso_prev_tool}" != "${tool}" ]; then
        # update cache
        #logerror "DBG RUN: ${tool} ${check_opt}"    # DBG here
        _ctso_prev_cache=$(${tool} ${check_opt} 2>&1)
        _ctso_prev_tool=${tool}
        #logwarning "DBG RESULT: $_ctso_prev_cache"  # DBG here
    fi

    echo "${_ctso_prev_cache}" | grep -w -e "${option_regex}" >/dev/null 2>&1
    ret="$?"
    if [ "$ret" = "0" ]; then
        # ok
        ret_feature=1
    fi

    if [ "${ignore_cache}" = "0" ] && [ -n "${_ctso_pers_cache_path}" ] ; then
        echo "export ${export_var_feature}=${ret_feature}" >> "${_ctso_pers_cache_path}"
    fi

    _logdebug 2 "scan tool feature: ${tool}: ${option_regex}: $( [ ${ret_feature} = 1 ] && echo_green "OK" || echo_red "NOK" )"
    # ----------------------------------------
    # return values
    eval "export ${export_var_feature}='${ret_feature}'"
    return $ret
}
_ctso_reset_pers_cache() #()
{
    if [ -f "${HDFIND_CTSO_CACHE_TMP_FILE}" ] ; then
        logdebug "reset csto persistence cache: ${HDFIND_CTSO_CACHE_TMP_FILE}"
        cmd="rm '${HDFIND_CTSO_CACHE_TMP_FILE}'"
        run "${cmd}"
        _ctso_pers_cache_loaded=0
    fi
}
if [ "${CMD_LINE_OPT__RESCAN_TOOLS_OPTS}" = "1" ] ; then
    logwarning "--rescan-tools-opts: reset tools options cache"
    _ctso_reset_pers_cache
fi
fi
if true; then                                                           # check tools, and features
# basic tooling

#grep features
_ctso "grep" "--color" GREP_CAN_COLOR
_ctso "grep" "-i" GREP_CAN_IGNORECASE
_ctso "grep" "-F" GREP_CAN_FIXEDSTRING
_ctso "grep" "-e" GREP_CAN_EXPLICIT_PATTERN

# find features
_ctso "find" "-print0" FIND_CAN_PRINT0
_ctso "find" "-wholename" FIND_CAN_WHOLENAME
_ctso "find" "-not" FIND_CAN_NOT
_ctso "find" "-maxdepth" FIND_CAN_MAXDEPTH
_ctso "find" "-size" FIND_CAN_SIZE
_ctso "find" "-iname" FIND_CAN_INAME
_ctso "find" "-or" FIND_CAN_OR

# xargs features
_ctso "xargs" "-0" XARGS_CAN_0
_ctso "xargs" "-P" XARGS_CAN_MULTIPROCESS
_ctso "xargs" "-I" XARGS_CAN_STRING_REPLACE

# optional tooling
# nl
_cet "nl" && NL_EXISTING="1";
# no nl, no sense for last search
[ "${NL_EXISTING}" != "1" ] && { logwarning "no nl: disable results persistence" ; HDGREP_LAST_RESULT_TMP_FILE=;}
if [ "${NL_EXISTING}" = "1" ]; then
    _ctso "nl" "-w" NL_CAN_NUMBER_WIDTH
    _ctso "nl" "-s" NL_CAN_NUMBER_SEPARATOR
fi
fi
# upgrade stuff, using _cse, so it can be overriden by user via ENV
_cse UPGRADE_LATEST_RELEASE_LINKS "
https://raw.githubusercontent.com/dhilfer/hdtools/main/hdfind
"
UPGRADE_UNIQUE_TOKEN="bba20c00-f039-45ec-affa-6be03c698135"
if true; then                                                           # upgrade: 2.2.0 # requires ___srV>=2.9.12, lognotice, logwarning, echo_red MODIFIED: VERSION -> __VERSION__
check_ip_with_ping() #(host)
{
    local __fn='check_ip_with_ping'; _chkargs ${__fn} 1 "$@"

    local host=
    host="${1}"

    if [ "${__is_win__}" = "1" ] ; then
        logdebug "(run): ping -w 1 -n 1 ${host}"
        if ping -w 1 -n 1 ${host}; then
            return 0
        fi
    else
        logdebug "(run): ping -W 1 -c 1 ${host}  >/dev/null 2>&1"
        if ping -W 1 -c 1 ${host}  >/dev/null 2>&1 ; then
            return 0
        fi
    fi

    return 1
}
download_file_with_wget() #(src_url, dst_file)
{
    local __fn="download_file_with_wget"; _chkargs "${__fn}" 2 "$@"

    local src_url=; src_url="${1}";
    local dst_file=; dst_file="${2}";

    # don't consider 1000 possible wget settings, just get it
    cmd="wget '${src_url}' -O - > '${dst_file}'"
    run "${cmd}"
    return $?
}
run_upgrade() #(name_info, upgrade_links, check_token, version_regex, target_path, target_file)
{
    local __fn="run_upgrade"; _chkargs "${__fn}" 6 "$@"

    local name_info=; name_info="${1}";
    local upgrade_links=; upgrade_links="${2}";
    local check_token=; check_token="${3}";
    local version_regex=; version_regex="${4}";
    local target_path=; target_path="${5}";
    local target_file=; target_file="${6}";

    local ret=
    local cmd=
    local err_msg=
    err_msg="upgrade failed

Try following:

* check upgrade link(s): ${upgrade_links}
* specify alternative link(s) using env var: UPGRADE_LATEST_RELEASE_LINKS
* check write access to: ${target_path}
* if you see wget error: The certificate of 'xxx' is not trusted, you can
  (re-)run with --verbose flag, copy/paste real wget command, then run it
  manually using --no-check-certificate flag.
"

    lognotice "run upgrade for ${name_info} ..."

    local target_tmp_file=
    target_tmp_file="${target_path}/${target_file}._upgrade.tmp"
    # try all available links until one of them works
    local one_upgrade_link=
    local remote_host=
    local download_ok=0
    __cIFS "${__fn}" "${__newline}"
    for one_upgrade_link in ${upgrade_links}; do
        if ___sw "${one_upgrade_link}" "#"; then
            continue
        fi
        # https://stackoverflow.com/questions/2497215/how-to-extract-domain-name-from-url
        remote_host=$(echo "${one_upgrade_link}" | sed -e 's/[^/]*\/\/\([^@]*@\)\?\([^:/]*\).*/\2/')
        lognotice "check update url: ${one_upgrade_link} (host: ${remote_host})"
        if ! check_ip_with_ping "${remote_host}"; then
            logwarning "update url: ${one_upgrade_link} (host: ${remote_host}) seems not be accessible"
            continue
        fi
        lognotice "download data to ${target_tmp_file}"
        if ! download_file_with_wget "${one_upgrade_link}" "${target_tmp_file}"; then
            # broken multiline colored on stderr on windows
            #logerror "${err_msg}"
            >&2 echo_red "  [error]: ${err_msg}"
            exit 1
        else
            download_ok=1
            break
        fi
    done
    __rIFS "${__fn}"

    if [ "${download_ok}" != "1" ] ; then
         >&2 echo_red "  [error]: ${err_msg}"
        exit 1
    fi

    # now check unique token
    lognotice "check contents ..."
    local tok_ok=
    tok_ok=$(cat "${target_tmp_file}" | grep "${check_token}")
    if [ -z "${tok_ok}" ]; then
        cmd="rm -f '${target_tmp_file}'"
        run "${cmd}"
        # broken multiline colored on stderr on windows
        >&2 echo_red "  [error]: ${err_msg}"
        exit 1
    fi

    # is valid
    local new_version_str=
    new_version_str=$(cat "${target_tmp_file}" | sed -nr "${version_regex}")

    # check old vs new version
    if [ $(___cvs $__VERSION__ $new_version_str ) = 1 ]; then
        >&2 echo_red "  [error]: NEW version: $new_version_str < CURRENT version: $__VERSION__, skip upgrade"
        cmd="rm -f '${target_tmp_file}'"
        run "${cmd}"
        exit 1
    fi


    lognotice "replace old version ..."
    cmd="mv '${target_tmp_file}' '${target_path}/${target_file}'"
    run "${cmd}"
    ret=$?
    if [ "${ret}" != "0" ]; then
        # broken multiline colored on stderr on windows
        >&2 echo_red "  [error]: ${err_msg}"
        exit 1
    fi

    if [ "${__is_win__}" != "1" ] ; then
        # chmod in linux only
        cmd="chmod +x '${target_path}/${target_file}'"
        run "${cmd}"
    fi

    lognotice "ALL GOOD. ${name_info} was upgraded: ${__VERSION__} -> ${new_version_str}"
    exit 0
}
fi
if true; then                                                           # work helper
get_ONE_pattern_set() #(pattern_in, *find_p, *grep_p)
{
    local __fn='get_ONE_pattern_set'; _chkargs ${__fn} 3 "$@"

    local pattern_in=
    local export_var_find_p=
    local export_var_grep_p=
    pattern_in="${1}"
    export_var_find_p="${2}" ; eval "export ${export_var_find_p}"
    export_var_grep_p="${3}" ; eval "export ${export_var_grep_p}"

    # ----------
    local ret_find_p=
    local ret_grep_p=


    # ----------------------------------------
    local find_p=
    local grep_p=
    local tmp=

    find_p="${pattern_in}"
    grep_p="${pattern_in}"


    if ___sw "${grep_p}" "*"; then
        grep_p=$(echo "${grep_p}" | cut -c2-)
    fi
    tmp=${#grep_p}
    tmp=$((tmp-1))
    if ___ew "${grep_p}" "*"; then
        grep_p=$(echo "${grep_p}" | cut -c1-${tmp})
    fi
    grep_p=$(echo "${grep_p}" | sed -r 's!\*!\.\*!g')

    if [ "${CMD_LINE_OPT__EXACT}" != "1" ] ; then
        if ___sw "${find_p}" "*" || ___ew "${find_p}" "*"; then
            true # pass
        else
            find_p="*${find_p}*"
        fi
    fi

    ret_find_p="${find_p}"
    ret_grep_p="${grep_p}"

    # ----------------------------------------
    # return values
    eval "export ${export_var_find_p}='${ret_find_p}'"
    eval "export ${export_var_grep_p}='${ret_grep_p}'"
    return 0
}
get_real_find_file_and_grep_patterns() #(use_p0, find_options_size, find_options_type, *real_find_file_pattern, *real_grep_for_this, *real_find_file_pattern_info)
{
    local __fn="get_real_find_file_and_grep_patterns"; _chkargsm "${__fn}" 6 "$@"

    local use_p0=; use_p0="${1}";
    local find_options_size=; find_options_size="${2}";
    local find_options_type=; find_options_type="${3}";
    local export_var_real_find_file_pattern=; export_var_real_find_file_pattern="${4}";
    eval "export ${export_var_real_find_file_pattern}=";
    local export_var_real_grep_for_this=; export_var_real_grep_for_this="${5}";
    eval "export ${export_var_real_grep_for_this}=";
    local export_var_real_find_file_pattern_info=; export_var_real_find_file_pattern_info="${6}";
    eval "export ${export_var_real_find_file_pattern_info}=";
    local ret_real_find_file_pattern=
    local ret_real_grep_for_this=
    local ret_real_find_file_pattern_info=

    # ---

    shift 6
    local find_file_pattern=
    local find_file_pattern_info=
    local grep_for_this=
    local tmp=
    local i=

    local ignore_search_case_for_grep=
    local ignore_search_case_for_find="-name"
    if [ "${CMD_LINE_OPT__IGNORE_CASE}" = "1" ] ; then
        ignore_search_case_for_grep="-i"
        ignore_search_case_for_find="-iname"
    fi

    if [ $# -eq 0 ]; then
        echo "${BASIC_USAGE}"
        exit 1
    elif [ $# -gt 1 ]; then
        if [ "${FIND_CAN_OR}" != "1" ] ; then
            CMD_LINE_OPT__VERBOSE=1
            logerror "'find' does not support -or, search for more than one PATTERN is not possible"
            exit 1
        fi
    fi

    local pattern_in=
    local pattern_in_fix=
    local _fr=0
    local _p0=
    [ "${FIND_CAN_PRINT0}" = "1" ] && [ "${XARGS_CAN_0}" = "1" ] && _p0="-print0";
    while [ $# -gt 0 ]; do
        if [ $_fr -ne 0 ]; then
            grep_for_this="${grep_for_this}\\|"
            find_file_pattern="${find_file_pattern} -or"
        fi

        _fr=1
        pattern_in=${1}
        # make sure user didn't specify a path: e.g.: ./js/hd/ui/hd_ui.js
        # take LAST part only, throw warning in verbose mode
        pattern_in_fix=${pattern_in##*/}
        if [ "${pattern_in}" != "${pattern_in_fix}" ] ; then
            logwarning "you specified a PATH to search for: '${pattern_in}', this is NOT how it should work"
            logwarning "I assume you look for: '${pattern_in_fix}', I'll search for that"
        fi
        get_ONE_pattern_set "${pattern_in_fix}" FIND_P GREP_P

        find_file_pattern_info="${find_file_pattern_info}\"${FIND_P}\", " # keep comma here!
        find_file_pattern="${find_file_pattern} ${ignore_search_case_for_find} \"${FIND_P}\" ${find_options_size} ${find_options_type}"
        if [ "${use_p0}" = "1" ] ; then
            find_file_pattern="${find_file_pattern} ${_p0}"
        fi

        grep_for_this="${grep_for_this}${GREP_P}"

        shift 1
    done
    if [ "${CMD_LINE_OPT__MD5}" != "1" ] ; then
        ret_real_find_file_pattern="${find_file_pattern}"
    else
        # on md5 search, deliver all, but search for files only
        ret_real_find_file_pattern="-type f ${_p0}"
    fi
    ret_real_grep_for_this="\"${grep_for_this}\""
    ret_real_find_file_pattern_info="$find_file_pattern_info"

    # ---

    # return values
    eval "export ${export_var_real_find_file_pattern}='${ret_real_find_file_pattern}'"
    eval "export ${export_var_real_grep_for_this}='${ret_real_grep_for_this}'"
    eval "export ${export_var_real_find_file_pattern_info}='${ret_real_find_file_pattern_info}'"
    return 0
}

string_isnumber() { [ -z "${1}" ] && return 1 ; case ${1} in ''*[!0-9]*) return 1 ;; esac; return 0; }
string_len() #(str)
{
    local l=$(echo "${1}" | wc -c )
    l=$((l-1))
    echo ${l}
}
# full support for negative indexes for start and end, end is optional
string_slice() #(str, pos, endpos=)
{
    local str=
    local pos=
    local endpos=
    str="${1}"
    pos=${2}
    endpos=${3}
    local len=
    len=$(string_len "${str}")
    [ -z ${endpos} ] && endpos=${len}
    if [ ${pos} -lt 0 ] ; then pos=$((len+pos)); fi
    if [ ${pos} -lt 0 ] ; then pos=0; fi
    if [ ${endpos} -lt 0 ] ; then endpos=$((len+endpos));
    elif [ ${endpos} -eq 0 ] || [ ${endpos} -gt ${len} ] ; then endpos=${len} ; fi

    if [ ${len} -eq 0 ] || [ ${endpos} -lt 0 ] || [ ${pos} -ge ${endpos} ] || [ ${pos} -gt $((${len}-1)) ] ; then
        echo ""
        return
    fi
    pos=$((pos+1))
    local cmd=
    cmd='echo "'${str}'" | cut -c'${pos}'-'${endpos}
    eval "${cmd}"
}
prep_find_size() #(user_size, *real_size)
{
    local __fn='prep_find_size'; _chkargs ${__fn} 2 "$@"

    local user_size=
    local export_var_real_size=
    user_size="${1}"
    export_var_real_size="${2}" ; eval "export ${export_var_real_size}="

    # ----------
    local ret_real_size=
    # ----------------------------------------

    local pref=
    local suff=
    local val=
    if string_isnumber "${user_size}"; then
        pref="-"
        suff="M"
        val="${user_size}"
    else
        # try not to use "fancy" patterns e.g. ${#i}, ${i: -1},  ash, dash will fail
          if ___sw "${user_size}" '+'; then pref='+'; val=$(string_slice "${user_size}" 1);
        elif ___sw "${user_size}" '-'; then pref='-'; val=$(string_slice "${user_size}" 1);
        elif string_isnumber "$(echo "${user_size}" | cut  -c1 )"; then pref='-'; val="${user_size}" # default '-': less than
        else
            logerror "wrong value for --size/-s (prefix): ${user_size}"
            exit 1
        fi

        if string_isnumber "${val}"; then
            suff="M"
        else
            # messy but safe
              if ___ew "${user_size}" 'c'; then suff='c'
            elif ___ew "${user_size}" 'k'; then suff='k'
            elif ___ew "${user_size}" 'M'; then suff='M'
            elif ___ew "${user_size}" 'G'; then suff='G'
            else
                logerror "wrong value for --size/-s (suffix): ${user_size}"
                exit 1
            fi
            val=$(echo "${val}" | tr "${suff}" ' ') # remove suffix, cheap
            val=$(echo $val)
        fi
    fi
    if ! string_isnumber "${val}"; then
        logerror "wrong value for --size/-s (value): ${user_size}"
        exit 1
    fi
    logdebug "search for SIZE: ""$(echo_red "${pref}${val}${suff}")"

    #rescale all vals to bytes (busysbox find may not understand M, G)
    local real_val=
    real_val="${val}"
    if [ "${suff}" = "c" ] ; then
        true # pass
    elif [ "${suff}" = "k" ] ; then
        real_val=$((real_val*1024))
    elif [ "${suff}" = "M" ] ; then
        real_val=$((real_val*1024*1024))
    elif [ "${suff}" = "G" ] ; then
        real_val=$((real_val*1024*1024*1024))
    fi
    ret_real_size="${pref}${real_val}c"

    # ----------------------------------------
    # return values
    eval "export ${export_var_real_size}='${ret_real_size}'"
    return 0
}
fi

main()
{
    if [ "${CMD_LINE_OPT__UPGRADE}" = "1" ] ; then
        CMD_LINE_OPT__VERBOSE="1"
        export CMD_LINE_OPT__VERBOSE
        CMD_LINE_OPT__DRY="0"
        export CMD_LINE_OPT__DRY
        run_upgrade 'hdfind' "${UPGRADE_LATEST_RELEASE_LINKS}" "${UPGRADE_UNIQUE_TOKEN}" 's!^__VERSION__="(.+)"$!\1!p' "${__path__}" "${__file__}"
        exit $? # always exit after upgrade!
    fi


    if [ "${CMD_LINE_OPT__IGNORE_EXCLUDE}" = "1" ] ; then
        FIND_IGNORE_PATTTERNS=
    fi

    logdebug "last result persistence: ${HDGREP_LAST_RESULT_TMP_FILE}"
    logdebug "tools options cache (refresh with: --rescan-tools-opts): ${HDFIND_CTSO_CACHE_TMP_FILE}"

    local ign_info=
    __cIFS '_info_ign_' '
'
    for i in ${FIND_IGNORE_PATTTERNS} ; do
        ign_info="${ign_info} '${i}'"
    done
    __rIFS '_info_ign_'
    logdebug "exclude path patterns: ${ign_info}"


    [ "${CMD_LINE_OPT__DRY}" = "1" ] && {
         echo_red "This is a DRY run. No real search is performed";
         CMD_LINE_OPT__VERBOSE="1";
         }

    local search_in_this_directory=

    local i=
    local color_txt=

    search_in_this_directory="${CMD_LINE_OPT__CHDIR}"
    if ___sw "$search_in_this_directory" "/"; then
        true # pass
    else
        if ___sw "$search_in_this_directory" "./"; then
            true # pass
        else
            search_in_this_directory="./$search_in_this_directory"
        fi
    fi
    if ! ___ew "$search_in_this_directory" "/"; then
        search_in_this_directory="$search_in_this_directory/"
    fi

    # feature checks
    if [ "${CMD_LINE_OPT__IGNORE_CASE}" = "1" ] && [ "${FIND_CAN_INAME}" != "1" ] ; then
        CMD_LINE_OPT__VERBOSE=1
        logerror "'find' does not support -iname (ignore case in names)"
        exit 1
    fi

    # normalize options in case of MD5 search
    local md5_txt="FILE PATTERN(s)"
    if [ "${CMD_LINE_OPT__MD5}" = "1" ] ; then
        md5_txt="FILES have MD5 hash"
        CMD_LINE_OPT__IGNORE_CASE="0"
        CMD_LINE_OPT__EXACT="1"
    fi

    # handle preface
    local show_defaults=
    local show_dirs_only=
    local show_match_only=
    local use_p0="1"
    show_defaults="1"
    show_dirs_only="0"
    show_match_only="0"
    if [ "${CMD_LINE_OPT__SHOW_DIRS_ONLY}" = "1" ]; then
        show_defaults="0"
        show_dirs_only="1"
        show_match_only="1"
    elif [ "${CMD_LINE_OPT__SHOW_MATCH_ONLY}" = "1" ]; then
        show_defaults="0"
        show_dirs_only="0"
        show_match_only="1"
        use_p0="0"
    fi
    if [ "${CMD_LINE_OPT__SHOW_DEFAULTS}" = "1" ]; then
        show_defaults="1"
        show_dirs_only="0"
        show_match_only="0"
    fi
    if [ ${show_dirs_only} = "1" ] && [ "${XARGS_CAN_STRING_REPLACE}" != "1" ] ; then
        logerror "'xargs' does not support -I (Replace STR), cannot run with --show-dirs-only"
        exit 1
    fi

    # search size
    local find_options_size=
    if [ -n "${CMD_LINE_OPT__SIZE}" ]; then
        if [ "${FIND_CAN_SIZE}" = "1" ]; then
            prep_find_size "${CMD_LINE_OPT__SIZE}" REAL_SIZE
            find_options_size="-size ${REAL_SIZE}"
        else
            logwarning "'find' does not support '-size', --size will be ignored"
        fi
    fi

    # search type
    # if nothing is set -> we search for all
    local type_options=
#    if [ "${CMD_LINE_OPT__MD5}" = "1" ] ; then
#        type_options="${type_options} -type f";
#    else
        if [ "${CMD_LINE_OPT__TYPE_FILE}" = "1" ] ; then
            [ -n "${type_options}" ] && type_options="${type_options} -o"
            type_options="${type_options} -type f";
            logdebug "search for TYPE: $(echo_red file)"
        fi
        if [ "${CMD_LINE_OPT__TYPE_DIR}" = "1" ] ; then
            [ -n "${type_options}" ] && type_options="${type_options} -o"
            type_options="${type_options} -type d";
            logdebug "search for TYPE: $(echo_red dir)"
        fi
        if [ "${CMD_LINE_OPT__TYPE_LINK}" = "1" ] ; then
        [ -n "${type_options}" ] && type_options="${type_options} -o"
            type_options="${type_options} -type l";
            logdebug "search for TYPE: $(echo_red link)"
        fi
        if [ "${CMD_LINE_OPT__TYPE_CHARDEV}" = "1" ] ; then
        [ -n "${type_options}" ] && type_options="${type_options} -o"
            type_options="${type_options} -type c";
            logdebug "search for TYPE: $(echo_red chardev)"
        fi

#    fi
    if [ -n "${type_options}" ] ; then
        type_options="\( ${type_options} \)";
    fi

    get_real_find_file_and_grep_patterns "${use_p0}" "${find_options_size}" "${type_options}" REAL_FIND_FILE_PATTERN REAL_GREP_FOR_THIS REAL_FIND_FILE_PATTERN_INFO "$@"
    local find_file_pattern=
    local grep_for_this=
    local find_file_pattern_info=
    find_file_pattern="${REAL_FIND_FILE_PATTERN}"
    grep_for_this="${REAL_GREP_FOR_THIS}"
    find_file_pattern_info=${REAL_FIND_FILE_PATTERN_INFO}

    # handle color
    local color_txt=
    if [ "${GREP_CAN_COLOR}" = "1" ] ; then
        color_txt='--color="always"'
        if [ "${CMD_LINE_OPT__DISABLE_COLOR}" = "1" ]; then
            color_txt=
        fi
    else
        logwarning "'grep' does not support colors"
    fi

    # print some info for user
    if [ "${DO_I_RUN_INTERACTIVELY}" != "1" ]; then
        logdebug "search for ${md5_txt}: ""$(echo_red "${find_file_pattern_info}")"" in DIR ""$(echo_red "\"${search_in_this_directory}\"")"
    else
        logdebug "search for ${md5_txt}: ""$(echo_red "${find_file_pattern_info}")"" in LIST OF PATHS given via ""$(echo_red stdin)"""
        if [ "${SED_SUPPORTS_BINARY_PATTERNS}" != "1" ] ; then
            logwarning "your 'sed' does not support binary patterns, I'll not be able to strip colors from stdin"
        fi
    fi


    #find
    local find_cmd=
    local find_options=

    find_cmd="find"

    if [ "${CMD_LINE_OPT__FOLLOW_SYMLINKS}" = "1" ] ; then
        find_cmd="${find_cmd} -L"
    fi

    # search depth
    if [ -n "${CMD_LINE_OPT__DEPTH}" ]; then
        if [ "${FIND_CAN_MAXDEPTH}" = "1" ]; then
            find_options="${find_options} -maxdepth ${CMD_LINE_OPT__DEPTH}"
        else
            logwarning "'find' does not support '-maxdepth', --depth will be ignored"
        fi
    fi

    local ignore_tmp=
    if [ "${FIND_CAN_WHOLENAME}" = "1" ] && [ "${FIND_CAN_NOT}" = "1" ]; then
        __cIFS '_find_ign_' '
'
        for i in ${FIND_IGNORE_PATTTERNS} ; do
            ignore_tmp=${i}
            ___sw "${ignore_tmp}" "*" || ignore_tmp="*${ignore_tmp}"
            #___ew "${ignore_tmp}" "*" || ignore_tmp="${ignore_tmp}*"
            find_options="${find_options} -not -wholename '${ignore_tmp}'";
        done
        __rIFS '_find_ign_'

    else
        logwarning "'find' does not support '-not -wholename', therefore no search paths can be ignored"
        logwarning "    desired paths to skip: ${FIND_IGNORE_PATTTERNS}"
    fi
    #if [ "${CMD_LINE_OPT__MD5}" != "1" ] ; then
        find_options="${find_options} ${find_file_pattern}";
    #else
        ## in md5 case get them all, let xargs run parallel md5sum
        #true # pass
    #fi
    #[ "${FIND_CAN_PRINT0}" = "1" ] && [ "${XARGS_CAN_0}" = "1" ] && find_options="${find_options} -print0";

    # xargs
    local xargs_cmd=
    local xargs_options=

    xargs_cmd="xargs"
    xargs_options="${xargs_options} -r"

    [ "${FIND_CAN_PRINT0}" = "1" ] && [ "${XARGS_CAN_0}" = "1" ] && xargs_options="${xargs_options} -0";
    [ "${XARGS_CAN_MULTIPROCESS}" = "1" ] && xargs_options="${xargs_options} -P0";

    if [ "${CMD_LINE_OPT__MD5}" = "1" ] ; then
        xargs_options="${xargs_options} md5sum";
    else
        xargs_options="${xargs_options} ls ${color_txt} -ldh";
    fi

    # grep
    local grep_cmd=
    local grep_options=
    export LC_ALL=C

    grep_cmd="grep"
    #[ "${GREP_CAN_FIXEDSTRING}" = "1" ] && grep_options="${grep_options} -F";
    [ "${GREP_CAN_IGNORECASE}"  = "1" ] && grep_options="${grep_options} ${ignore_search_case_for_grep}";
    # important: must be the last one
    [ "${GREP_CAN_EXPLICIT_PATTERN}" = "1" ] && grep_options="${grep_options} -i -e";


    # nl
    local nl_cmd=
    local nl_options=
    if [ "${NL_EXISTING}" = "1" ]; then
        nl_cmd="nl"
        [ "${NL_CAN_NUMBER_WIDTH}" = "1" ] && nl_options="${nl_options} -w 3";
        [ "${NL_CAN_NUMBER_SEPARATOR}" = "1" ] && nl_options="${nl_options} -s ' | '";
    fi

    local cmd=
    local cmd_pre=
    local cmd_post=
    local cmd_pesistence_redirect=
    # find itself
    cmd_pre="${find_cmd} '${search_in_this_directory}' ${find_options}"

    # add infos for user (in case of md5sum search these are neccessary steps)
    if [ "${show_defaults}" = "1" ]; then
        # show type, size access rights, or check md5
        cmd_post="${cmd_post} | ${xargs_cmd} ${xargs_options}"
        # color what user had searched for, with grep
        if [ "${grep_for_this}" != '"."' ] ; then
            cmd_post="${cmd_post} | ${grep_cmd} ${color_txt}${grep_options} ${grep_for_this}"
        fi
        # number results
        [ "${NL_EXISTING}" = "1" ] && cmd_post="${cmd_post} | ${nl_cmd} ${nl_options}"
    else
        # show_match_only
        #if [ "${show_match_only}" = "1" ] ; then
            if [ "${CMD_LINE_OPT__MD5}" = "1" ] ; then
                # in case of md5 search we still need prepared xargs cmd
                cmd_post="${cmd_post} | ${xargs_cmd} ${xargs_options}"
                # then we need to filter relevant and strip sum itself
                cmd_post="${cmd_post} | grep ${grep_for_this}"
                cmd_post="${cmd_post} | sed -r  's![0-9a-z]{32}( +)(.+)!\2!g'"
            else
                if [ "${FIND_CAN_PRINT0}" = "1" ] && [ "${XARGS_CAN_0}" = "1" ]; then
                    if [ "${show_dirs_only}" = "1" ] ; then
                        # use xargs to show dirs only
                        # escape " and $ within sh -c ''
                        cmd_post="${cmd_post} | ${xargs_cmd} -0 -n1 -I '_p1' sh -c '_f(){ i=\$1; echo \"\${i%/*}\" || echo \"\$1\";}; _f \"_p1\"' | sort | uniq"
                    else
                        cmd_post="${cmd_post}"
                    fi
                else
                    # find will run normally, no xargs is invoked
                    if [ "${show_dirs_only}" = "1" ] ; then
                        # use xargs to show dirs only
                        # escape " and $ within sh -c ''
                        cmd_post="${cmd_post} | ${xargs_cmd} -n1 -I '_p1' sh -c '_f(){ i=\$1; [ ! -d \"\$1\" ] && echo \"\${i%/*}\" || echo \"\$1\";}; _f \"_p1\"'"
                    fi
                fi
            fi
        #fi
    fi

    # redirect output to tmpfile, using last search results in other tools
    if [ "${show_defaults}" = "1" ] && [ -n "${HDGREP_LAST_RESULT_TMP_FILE}" ]; then
        cmd_pesistence_redirect=" | tee '${HDGREP_LAST_RESULT_TMP_FILE}'"
    fi

    if [ "${DO_I_RUN_INTERACTIVELY}" != "1" ]; then
        cmd="${cmd_pre}${cmd_post}${cmd_pesistence_redirect}"
        run "$cmd"
    else
        # we get data from a pipe, assume this is a list of paths, where we should search
        while read -r one_line_from_stdin ; do
            one_line_from_stdin=$(strip_colors "${one_line_from_stdin}")
            logdebug "find in: '${one_line_from_stdin}' ..."

            cmd_pre="${find_cmd} '${one_line_from_stdin}' ${find_options}"
            cmd="${cmd_pre}${cmd_post}${cmd_pesistence_redirect}"
            run "${cmd}"
        done
    fi
    return 0
}
if [ "${__name__}" = "__main__" ] ; then
    main "$@"
    exit $?
fi
